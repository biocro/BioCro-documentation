<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>BioCro as a Dynamical System • BioCro</title>
<script src="../../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../../deps/headroom-0.11.0/headroom.min.js"></script><script src="../../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../../deps/search-1.0.0/fuse.min.js"></script><script src="../../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../../pkgdown.js"></script><meta property="og:title" content="BioCro as a Dynamical System">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../../index.html">BioCro</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">3.2.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../../about_pkgdown_documentation.html">About</a></li>
<li class="nav-item"><a class="nav-link" href="../../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><h6 class="dropdown-header" data-toc-skip>GENERAL BIOCRO USAGE</h6></li>
    <li><hr class="dropdown-divider"></li>
    <li><a class="dropdown-item" href="../../articles/BioCro.html">Getting Started with BioCro (HTML)</a></li>
    <li><a class="dropdown-item" href="../../articles/web_only/a_practical_guide_to_biocro.pdf">A Practical Guide to BioCro (PDF)</a></li>
    <li><a class="dropdown-item" href="../../articles/web_only/a_practical_guide_to_biocro.R">    [R code]</a></li>
    <li><a class="dropdown-item" href="../../articles/web_only/quantitative_model_comparison.pdf">Quantitative Comparison Between Two Photosynthesis Models (PDF)</a></li>
    <li><a class="dropdown-item" href="../../articles/web_only/quantitative_model_comparison.R">    [R code]</a></li>
    <li><a class="dropdown-item" href="../../articles/web_only/BioCro-II_Paper--Section-1.1-example.html">BioCro II Paper: Section 1.1 Example (HTML)</a></li>
    <li><a class="dropdown-item" href="../../articles/web_only/dynamical_systems.pdf">BioCro as a Dynamical System</a></li>
    <li><a class="dropdown-item" href="../../articles/web_only/an_introduction_to_biocro.pdf">An Introduction to BioCro for Those Who Want to Add Models (PDF)</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>CROP GROWTH MODELING TOPICS</h6></li>
    <li><hr class="dropdown-divider"></li>
    <li><a class="dropdown-item" href="../../articles/web_only/avoiding_pitfalls_fvcb.html">Avoiding Pitfalls When Using the FvCB Model (HTML)</a></li>
    <li><a class="dropdown-item" href="../../articles/web_only/thick_layer_absorption.html">Light Absorption by a Thick Layer (HTML)</a></li>
    <li><a class="dropdown-item" href="../../articles/web_only/ball_berry_model.html">Using the Ball-Berry Model (HTML)</a></li>
    <li><a class="dropdown-item" href="../../articles/web_only/canopy_photosynthesis.html">Multi-layer Canopy Photosynthesis Models (HTML)</a></li>
    <li><a class="dropdown-item" href="../../articles/web_only/energy_balance.html">Energy Balance, Leaf Temperature, and Transpiration (HTML)</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../../../bookdown/index.html">Developer's Manual</a></li>
<li class="nav-item"><a class="nav-link" href="../../news/index.html">Changelog</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-c-library" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">C++ Library</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-c-library">
<li><a class="dropdown-item" href="../../../doxygen/doxygen_docs_complete/index.html">Complete Doxygen Documentation</a></li>
    <li><a class="dropdown-item" href="../../../doxygen/doxygen_docs_framework/index.html">Framework Documentation</a></li>
    <li><a class="dropdown-item" href="../../../doxygen/doxygen_docs_modules/index.html">BioCro Module Documentation</a></li>
    <li><a class="dropdown-item" href="../../../doxygen/doxygen_docs_modules_public_members_only/index.html">BioCro Module Documentation (public members only)</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/biocro/biocro/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>BioCro as a Dynamical System</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/biocro/biocro/blob/v3.2.0/vignettes/web_only/dynamical_systems.Rmd" class="external-link"><code>vignettes/web_only/dynamical_systems.Rmd</code></a></small>
      <div class="d-none name"><code>dynamical_systems.Rmd</code></div>
    </div>

    
    
<!-- vector space -->
<!-- tuple or vector -->
<!-- reals -->
<!-- integers -->
<!-- natural numbers -->
<!-- identity function -->
<!-- BioCro module -->
<!-- BioCro system -->
<!-- Image operator -->
<div class="section level2">
<h2 id="dynamical-systems-real-and-mathematical">Dynamical systems, real and mathematical<a class="anchor" aria-label="anchor" href="#dynamical-systems-real-and-mathematical"></a>
</h2>
<p>In his book <em>Computation, Dynamics, and Cognition</em> <span class="citation">(<a href="#ref-Giunti1997-GIUCDS">Giunti
1997</a>)</span>, Giunti distinguishes between real dynamical systems
and mathematical dynamical systems:</p>
<blockquote>
<p>A real dynamical system is any real system that changes over time.
Therefore, since any real system can be thought to change in time (in
some respect), any real system is a real dynamical system. A
mathematical dynamical system, on the other hand, is an abstract
mathematical structure that can be used to describe the change of a real
system as an evolution through a series of states.</p>
</blockquote>
<p>It should be emphasized that when we create a mathematical system to
model a real one, we are doing more than just quantifying attributes of
the real system; we are also selecting which attributes to incorporate
into our model and which ones to ignore. For there are an endless
variety of attributes which could describe the state of a real system,
and we can’t even begin to hope to be able to model all of them.</p>
<p>As stated in the Giunti quote, a mathematical dynamical system will
describe the change of a real system as an evolution through a series of
states. (For now, we will interpret “series of states” loosely, so as to
encompass models that describe this change as a continuous evolution of
the system state as well as those that describe change in terms of a
discrete sequence of states.) The real usefulness of such a mathematical
structure, however, comes when it goes beyond merely describing the
series of states: the real power comes when we are able to derive a
complete picture of the evolution of a system from only partial
knowledge of the system, knowledge possibly consisting of, for example,
the state of the system at some particular time, the environment in
which the system is operating, and some general knowledge of the
processes that determine how the system behaves.</p>
<div class="section level3">
<h3 id="an-example-the-falling-body-problem">An example: the falling-body problem <a class="anchor" aria-label="anchor" href="#an-example-the-falling-body-problem"></a>
</h3>
<p>A classic example from physics is the falling-body problem: Given a
stationary, compact, relatively dense object dropped from a height
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>h</mi><mn>0</mn></msub><annotation encoding="application/x-tex">h_0</annotation></semantics></math>
above the surface of the earth, what will be its height after a duration
of time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>?
The partial knowledge we have of this system consists of:</p>
<ol style="list-style-type: decimal">
<li><p>the initial height
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>h</mi><mn>0</mn></msub><annotation encoding="application/x-tex">h_0</annotation></semantics></math>
of the object</p></li>
<li><p>the initial velocity
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mn>0</mn></msub><annotation encoding="application/x-tex">v_0</annotation></semantics></math>
of the object (In this system, we’ll assume
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">v_0 = 0</annotation></semantics></math>:
the object is stationary to begin with.)</p></li>
<li><p>the magnitude, which we’ll call
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>,
of the downward acceleration of the body caused by the earth’s
gravitational field</p></li>
</ol>
<p>If we use the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">h(t)</annotation></semantics></math>
to embody the complete description of the evolution of the system—that
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">h(t)</annotation></semantics></math>
tells the height of the body after an elapsed time of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>—then
our initial knowledge of the system consists of a system of equations
putting certain constraints on the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>:
<!-- (no par break) --> <span class="math display">$$\begin{align}
  h(0)         &amp; = h_0      \notag \\
  h'(t)\big|_{t=0} &amp; = 0    \label{eq:ode-system} \\
  h''(t)       &amp; = -g       \notag
\end{align}$$</span> <!-- (no par break) --> (The third constraint would
more accurately be written as <!-- (no par break) --> <span class="math display">$$\begin{equation*}
  h''(t) = -g \quad\text{\emph{if} h(t) &gt; 0},
\end{equation*}$$</span> <!-- (no par break) --> but for simplicity, we
will only consider the system over durations sufficiently small that the
object has not yet hit the ground.)</p>
<p>In the field of differential equations, this is known as an
initial-value problem, and it can be shown that its unique solution is
given by <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>h</mi><mn>0</mn></msub><mo>−</mo><mn>1</mn><mi>/</mi><mn>2</mn><mspace width="0.167em"></mspace><mi>g</mi><msup><mi>t</mi><mn>2</mn></msup><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
  h(t) = h_0 - 1/2\,gt^2.
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
Thus, from knowing only the initial height and velocity of the object
and some basic principles of physics, we are able to obtain a complete
description of the evolution of this “falling object” system over
time.</p>
</div>
<div class="section level3">
<h3 id="some-comments-on-mathematical-abstraction">Some comments on mathematical abstraction<a class="anchor" aria-label="anchor" href="#some-comments-on-mathematical-abstraction"></a>
</h3>
<p>As we mentioned, any mathematical dynamical system that purports to
model a real system will necessarily leave much out. In choosing what
attributes to retain in our abstract model, there are two main
considerations: First, which attributes of the system are of most
interest to us? For a model of plant growth, this might include, for
example, the rate of growth (mass accumulation) of a plant; the nutrient
or energy content of the growing plant; the effects of a group of plants
on the surrounding environment, including the temperature and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">CO</mtext><mtext mathvariant="normal">2</mtext></msub><annotation encoding="application/x-tex">\text{CO}_\text{2}</annotation></semantics></math>
content of the surrounding air, or the rate of erosion of the soil
substrate; or the resilience of the plant in drought conditions.</p>
<p>Second, there are attributes that may not be of particular intrinsic
interest but may help in predicting the behavior of those attributes
that <em>are</em> of interest.</p>
<p>Returning to the falling-object model for a moment, if the primary
object of interest in the <em>real</em> falling object system is the
height of the object at any given time, then there are certain things
about the system we may safely ignore: the color of the object or the
time of day, for example, will probably have no bearing on the
trajectory of object’s motion. On the other hand, knowing the velocity
of the object at any given time is crucial to predicting its height over
time, even if we may have no intrinsic interest in knowing the
velocity.</p>
<p>Other attributes that <em>could</em> have some bearing on the motion
of the object are (to give a very few examples)</p>
<ul>
<li>the size and shape of the object</li>
<li>the mass of the object</li>
<li>the air currents in the vicinity of the object’s path</li>
</ul>
<p><!-- Pandoc seemingly doesn't allow lists in the middle of a
               paragraph, so we fake it.  --> But as the Italian
experimenters of the 16th century demonstrated, the weight of a compact
and relatively dense object has little effect upon the rate at which it
falls. It turns out, as a matter of fact, that the predictive accuracy
of our model, in which we look only at the height and downward velocity
of the object (and the ambient gravitational field) and ignore all other
attributes of the system, is rather good in the case of compact,
relatively-dense objects.</p>
<p>Of course, if we consider a non-compact object with relatively low
density, such as a feather, this model may not do a good job of
predicting its path as it falls through the air. We may find that in
order to accurately model the free-fall of a feather, we <em>do</em>
need to include additional attributes in our system, such as those that
help us take into account the effects of air resistance. This process,
whereby a model is compared against observations and then updated when
it fails to predict the behavior of the real system it is meant to
represent, is a key part of the scientific process and has been
responsible for a great deal of progress and understanding. Thus, it is
never a problem when the process of abstraction has left out too many
details; instead this is an opportunity to learn more about the real
world and the model. A central goal for BioCro is to make it relatively
easy to add new components to an existing model, allowing this type of
model development to occur more rapidly.</p>
</div>
</div>
<div class="section level2">
<h2 id="continuous-time-versus-discrete-time">Continuous time versus discrete time <a class="anchor" aria-label="anchor" href="#continuous-time-versus-discrete-time"></a>
</h2>
<p>In the system just shown—a mathematical model of a real-world
dynamical system—the differential equation constraining the solution has
an exact solution as an easily-computable function. Most often, however,
we will not be able to find an exact solution, and so we will have to
settle for a numerical solution.</p>
<p>We will show how to model the falling-object system numerically, even
though this is one case where we don’t really need to resort to such
methods.</p>
<div class="section level3">
<h3 id="eulers-method">Euler’s method<a class="anchor" aria-label="anchor" href="#eulers-method"></a>
</h3>
<p>Euler’s method, the most basic of methods for numerical integration
of ordinary differential equations, may be applied to any system in
which the current rate of change of each of the state variables may be
expressed as a function of the current state. Here, we use <em>state
variable</em> to mean any quantifiable attribute of a system whose value
we would like to predict; the <em>state</em> of a system is then the
conglomeration of the values of all of these variables at any particular
time. Euler’s method makes the assumption that, given a known state of a
system at some particular time, the state of the system at some very
small interval of time later can be closely approximated by assuming
that the rate of change of each state variable remains essentially
constant over that very small time interval.</p>
<p>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐬</mi><annotation encoding="application/x-tex">\mathbf{s}</annotation></semantics></math>
denotes the state, with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐬</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{s}(t)</annotation></semantics></math>
denoting its value at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
and if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
is one of the state variables, with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math>
denoting its value at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
then, given <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>x</mi><mi>/</mi><mi>d</mi><mi>t</mi><mo>=</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐬</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation*}
  dx/dt = f(\mathbf{s}),
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
we assume that for any sufficiently small interval of time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math>,
<!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>+</mo><mi>Δ</mi><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≈</mo><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐬</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><mi>Δ</mi><mi>t</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
  x(t+\Delta t) \approx x(t) + f(\mathbf{s}(t))\cdot\Delta t.
\end{equation*}</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="applying-eulers-method-to-the-falling-body-problem">Applying Euler’s method to the falling-body problem<a class="anchor" aria-label="anchor" href="#applying-eulers-method-to-the-falling-body-problem"></a>
</h3>
<p>In the system of equations ,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>
is the only system variable. But there is no valid equation that gives
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>h</mi><mi>/</mi><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">dh/dt</annotation></semantics></math>
as a function of the state when the state is represented by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>
alone.</p>
<p>To solve this problem, we will also consider the velocity to be a
part of the state. If we think of the state of a system as a record of
the system at a particular time that can be used to predict a future
state, it makes sense that the velocity should be included. For example,
if we know the position of an object but we do not even know if it is
moving upwards or downwards, we will not be able to predict its position
in the near future.</p>
<p>And so now, the states of our system have two components, height and
velocity, and we can think of each state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐬</mi><annotation encoding="application/x-tex">\mathbf{s}</annotation></semantics></math>
as a point in a 2-dimensional Euclidean space, that is,
<!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐬</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mn>0</mn></msub><mo>,</mo><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
  \mathbf{s} = (s_0, s_1).
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
We will identify the height
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>
with the first component
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mn>0</mn></msub><annotation encoding="application/x-tex">s_0</annotation></semantics></math>
and the velocity
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>
with the second component
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mn>1</mn></msub><annotation encoding="application/x-tex">s_1</annotation></semantics></math>.
We will consider
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>
to be the velocity in the upward direction so that when the object is
falling,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">v &lt; 0</annotation></semantics></math>.
We write
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">v(t)</annotation></semantics></math>
to denote
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>
as a function of time.</p>
<p>Since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>=</mo><mi>d</mi><mi>h</mi><mi>/</mi><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">v = dh/dt</annotation></semantics></math>,
we can rewrite the system as <!-- (no par break) --> <span class="math display">$$\begin{align}
  dh/dt &amp; = v   \label{eq:deriv_h} \\
  dv/dt &amp; = -g  \label{eq:deriv_v} \\
  h(0)  &amp; = h_0 \notag \\
  v(0)  &amp; = 0   \notag
\end{align}$$</span> <!-- (no par break) --> Now we can use equations
and to obtain the Euler method formulas for estimating the state at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>+</mo><mi>Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">t +
\Delta t</annotation></semantics></math> from the state at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>:
<!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>+</mo><mi>Δ</mi><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><mi>Δ</mi><mi>t</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>+</mo><mi>Δ</mi><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>g</mi><mo>⋅</mo><mi>Δ</mi><mi>t</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
  h(t + \Delta t) &amp; = h(t) + v(t)\cdot\Delta t \\
  v(t + \Delta t) &amp; = v(t) - g\cdot\Delta t
\end{align*}</annotation></semantics></math></p>
<p>Let us consider this system over some sequence of times
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>=</mo><msub><mi>t</mi><mn>0</mn></msub><mo>,</mo><msub><mi>t</mi><mn>1</mn></msub><mo>,</mo><msub><mi>t</mi><mn>2</mn></msub><mo>,</mo><msub><mi>t</mi><mn>3</mn></msub><mo>,</mo><mi>…</mi></mrow><annotation encoding="application/x-tex">0 = t_0, t_1,
t_2, t_3, \dots</annotation></semantics></math> where for each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>t</mi><mi>i</mi></msub><mo>+</mo><mi>Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">t_{i + 1} = t_i + \Delta t</annotation></semantics></math>.
Further, let write
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math>,
and let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>π</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>π</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math>
denote the projection of the state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐬</mi><annotation encoding="application/x-tex">\mathbf{s}</annotation></semantics></math>
onto its components, that is <!-- (no par break) --> <span class="math display">$$\begin{align}
  \pi_0(\mathbf{s}) &amp; = s_0 \\
  \intertext{and}
  \pi_1(\mathbf{s}) &amp;= s_1.
\end{align}$$</span> <!-- (no par break) --> Now we can write a
recursive definition for the state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐬</mi><annotation encoding="application/x-tex">\mathbf{s}</annotation></semantics></math>
as a function of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>:
<!-- (no par break) --> <span class="math display">$$\begin{align}
  \mathbf{s}(t_0) &amp;= (h_0, 0) \notag \\
  \mathbf{s}(t_{i + 1}) &amp;= (\pi_0(\mathbf{s}(t_i)) +  \delta \cdot
\pi_1(\mathbf{s}(t_i)),
                         \pi_1(\mathbf{s}(t_i)) - \delta\cdot
g)\quad\text{for i$\geq$0}.
                         \label{eq:falling_body_recursion}
\end{align}$$</span> <!-- (no par break) --> Note that we could also
express this definition using our original variable names and without
using the projection operators: <!-- (no par break) --> <span class="math display">$$\begin{align*}
  \mathbf{s}(t_0) &amp;= (h_0, 0) \notag \\
  \mathbf{s}(t_{i + 1}) &amp;= (h(t_i) +  \Delta t \cdot v(t_i),
                         v(t_i) - \Delta t \cdot g)\quad\text{for
i$\geq$0}.
\end{align*}$$</span> <!-- (no par break) --> Thus, Equation may seem
like a complicated way to write a relatively simple rule relating
height, velocity, and acceleration. This notation will, however, become
useful later when we consider systems less in terms a named state
variables and instead think of these variables as coordinates of a point
in a Euclidean space comprising the system state space.</p>
</div>
<div class="section level3">
<h3 id="note-about-abstraction-and-recursive-systems">Note about abstraction and recursive systems<a class="anchor" aria-label="anchor" href="#note-about-abstraction-and-recursive-systems"></a>
</h3>
<p>We have just performed the following abstraction to arrive at a
recursively-defined function giving the state of a system as a function
of time: <!-- (no par break) --> <span class="math display">$$\begin{equation*}
  \begin{array}{c}
    \text{\sc real system} \\
    \downarrow \\
    \text{\sc continuous mathematical system (ODE system)} \\
    \downarrow \\
    \text{\sc discrete-time approximation (recursive equations)}
  \end{array}
\end{equation*}$$</span> <!-- (no par break) --> One important point
here is that the process of developing a recursive equation (or a
discrete-time approximation) depends on the algorithm chosen for solving
the continuous ODE system. For example, if we had chosen to use the
fourth-order Runge-Kutta method rather than Euler’s method to solve the
falling-body problem, we would have arrived at a recursive definition
different from Equation . Nevertheless, it would represent the same
continuous system, and should (usually) produce a similar sequence of
states.</p>
<p>It should also be pointed out that not all discrete-time abstract
dynamical systems arise as abstractions of real systems or even as
abstractions of continuous-time abstract systems.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;There are also cases where it is convenient to abstract
directly from a (presumably continuous) real-world system to a discrete
mathematical model without passing through the intermediary stage of
making an ODE-based model. We shall say more about this in Section .&lt;/p&gt;"><sup>1</sup></a></p>
<p>Consider, for example, a system with a state space
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐙</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\mathbf{Z}^2</annotation></semantics></math>
consisting of all ordered pairs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐯</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>v</mi><mn>0</mn></msub><mo>,</mo><msub><mi>v</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{v} = (v_0, v_1)</annotation></semantics></math>
of integers, and a transition rule <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐯</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>π</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐯</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mi>π</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐯</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>π</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐯</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
  \mathbf{v}(t_{i + 1}) = (\pi_1(\mathbf{v}(t_i)), \pi_0(\mathbf{v}(t_i)) + \pi_1(\mathbf{v}(t_i))).
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
Given an initial state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐯</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{v}(t_0)</annotation></semantics></math>,
we now have a way to compute the state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐯</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{v}(t_i)</annotation></semantics></math>
at any time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>i</mi></msub><annotation encoding="application/x-tex">t_i</annotation></semantics></math>.
This abstract dynamical system may not have any relationship to any real
dynamical system we might imagine, but it is an abstract dynamical
system nevertheless.</p>
<p>(If we take
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐯</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{v}(t_0) = (0, 1)</annotation></semantics></math>,
by the way, the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>𝐍</mi><mo>→</mo><mi>𝐙</mi></mrow><annotation encoding="application/x-tex">F:
\mathbf{N}\to\mathbf{Z}</annotation></semantics></math> defined by the
rule <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>↦</mo><msub><mi>π</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐯</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{equation*}
  i \mapsto \pi_0(\mathbf{v}(t_i))
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
defines the Fibonacci sequence
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>8</mn><mo>,</mo><mn>13</mn><mo>,</mo><mi>…</mi><mspace width="0.167em"></mspace></mrow><annotation encoding="application/x-tex">0, 1, 1, 2, 3, 5, 8, 13, \dots\,</annotation></semantics></math>.)</p>
<p>Another class of discrete-time abstract dynamical systems are the
cellular automata. These, however, may have some value in modeling
real-world phenomena. (See, for example, <span class="citation">Deutsch
(<a href="#ref-alma99496872912205899">2005</a>)</span>.)</p>
</div>
</div>
<div class="section level2">
<h2 id="an-overview-of-some-abstract-dynamical-system-formulations">An overview of some abstract dynamical system formulations <a class="anchor" aria-label="anchor" href="#an-overview-of-some-abstract-dynamical-system-formulations"></a>
</h2>
<p>This section will provide a short survey of some formulations of
abstract dynamical systems; in later sections, we will discuss how these
formulations relate to the types of systems represented in BioCro.</p>
<p>(For a insightful and thoroughly abstract mathematical study of the
theory of general systems, dynamical and otherwise, see <span class="citation">Mesarović and Takahara (<a href="#ref-alma99267312205899">1975</a>)</span>.)</p>
<div class="section level3">
<h3 id="some-notational-preliminaries">Some notational preliminaries <a class="anchor" aria-label="anchor" href="#some-notational-preliminaries"></a>
</h3>
<p>As is common, we will take
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f: C \to B</annotation></semantics></math>
to mean
“<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
is a function with domain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
taking values in the set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>.”
Usually, this means
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(c)</annotation></semantics></math>
is defined for every
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">c\in C</annotation></semantics></math>,
but in what follows, we won’t always be entirely strict about this.
Following <span class="citation">Vaught (<a href="#ref-vaught">1985</a>)</span>, we write
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>B</mi><mi>C</mi></msup><annotation encoding="application/x-tex">B^C</annotation></semantics></math>
to denote the set of all such functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;This notation is meant to be suggestive of
exponentiation. In fact, if
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;annotation encoding="application/x-tex"&gt;B&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
and
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;annotation encoding="application/x-tex"&gt;C&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
are both finite sets having cardinalities
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy="false" form="postfix"&gt;∥&lt;/mo&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mo stretchy="false" form="postfix"&gt;∥&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding="application/x-tex"&gt;\|B\|&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
and
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy="false" form="postfix"&gt;∥&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mo stretchy="false" form="postfix"&gt;∥&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding="application/x-tex"&gt;\|C\|&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
respecively, then the cardinality
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy="false" form="postfix"&gt;∥&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;/msup&gt;&lt;mo stretchy="false" form="postfix"&gt;∥&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding="application/x-tex"&gt;\|B^C\|&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
of
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;msup&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;/msup&gt;&lt;annotation encoding="application/x-tex"&gt;B^C&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
will be
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy="false" form="postfix"&gt;∥&lt;/mo&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;msup&gt;&lt;mo stretchy="false" form="postfix"&gt;∥&lt;/mo&gt;&lt;mrow&gt;&lt;mo stretchy="false" form="postfix"&gt;∥&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mo stretchy="false" form="postfix"&gt;∥&lt;/mo&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding="application/x-tex"&gt;\|B\|^{\|C\|}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;.
For example, if
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo stretchy="false" form="prefix"&gt;{&lt;/mo&gt;&lt;mtext mathvariant="normal"&gt;apple&lt;/mtext&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mtext mathvariant="normal"&gt;pepper&lt;/mtext&gt;&lt;mo stretchy="false" form="postfix"&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding="application/x-tex"&gt;C=\{\text{apple}, \text{pepper}\}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
and
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo stretchy="false" form="prefix"&gt;{&lt;/mo&gt;&lt;mtext mathvariant="normal"&gt;red&lt;/mtext&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mtext mathvariant="normal"&gt;yellow&lt;/mtext&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mtext mathvariant="normal"&gt;green&lt;/mtext&gt;&lt;mo stretchy="false" form="postfix"&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding="application/x-tex"&gt;B=\{\text{red},
\text{yellow}, \text{green}\}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;, then
there are
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy="false" form="postfix"&gt;∥&lt;/mo&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;msup&gt;&lt;mo stretchy="false" form="postfix"&gt;∥&lt;/mo&gt;&lt;mrow&gt;&lt;mo stretchy="false" form="postfix"&gt;∥&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mo stretchy="false" form="postfix"&gt;∥&lt;/mo&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding="application/x-tex"&gt;\|B\|^{\|C\|} = 3^2 =
9&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt; possible mappings of the two food
items to the three colors.&lt;/p&gt;'><sup>2</sup></a> We use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐑</mi><annotation encoding="application/x-tex">\mathbf{R}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐙</mi><annotation encoding="application/x-tex">\mathbf{Z}</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐍</mi><annotation encoding="application/x-tex">\mathbf{N}</annotation></semantics></math>
to denote the real numbers, the integers, and the natural numbers (the
finite ordinals, including zero), respectively.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐙</mi><mo>+</mo></msup><annotation encoding="application/x-tex">\mathbf{Z}^+</annotation></semantics></math>
denotes the <em>positive</em> integers.</p>
<p>Following von Neumann, it will sometimes be convenient to identify
each natural number
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
with the set of all of its predecessors. For example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>4</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">5 = \{0, 1, 2, 3, 4\}</annotation></semantics></math>.
This is particularly useful when speaking of Euclidian spaces. For
example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mn>3</mn></msup><annotation encoding="application/x-tex">\mathbf{R}^3</annotation></semantics></math>,
Euclidean 3-space, is usually thought of as the set of all 3-coordinate
vectors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x, y,
z)</annotation></semantics></math>. But we can equally well consider it
to be the set of all mappings
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false" form="postfix">}</mo><mo>→</mo><mi>𝐑</mi></mrow><annotation encoding="application/x-tex">v: \{0,1,2\}\to \mathbf{R}</annotation></semantics></math>,
which, using the set-of-functions notation given above, can be denoted
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false" form="postfix">}</mo></mrow></msup><annotation encoding="application/x-tex">\mathbf{R}^{\{0,1,2\}}</annotation></semantics></math>.
(Or, using von Neumann’s notion of ordinals, this, too, is denoted
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mn>3</mn></msup><annotation encoding="application/x-tex">\mathbf{R}^3</annotation></semantics></math>,
since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">3=\{0,1,2\}</annotation></semantics></math>!)
Thus, we can identify a 3-tuple
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x,y,z)</annotation></semantics></math>
with a mapping
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false" form="postfix">}</mo><mo>→</mo><mi>𝐑</mi></mrow><annotation encoding="application/x-tex">v: \{0,1,2\}\to \mathbf{R}</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">v(0) = x</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">v(1) = y</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">v(2)
= z</annotation></semantics></math>. We often write
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mi>i</mi></msub><annotation encoding="application/x-tex">v_i</annotation></semantics></math>
in place of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">v(i)</annotation></semantics></math>
and identify a mapping
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo><mo>→</mo><mi>𝐑</mi></mrow><annotation encoding="application/x-tex">v: \{0, 1, 2, \dots, n-1\}\to \mathbf{R}</annotation></semantics></math>
with an n-tuple or n-coordinate vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐯</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>v</mi><mn>0</mn></msub><mo>,</mo><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><msub><mi>v</mi><mn>2</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>v</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{v}=(v_0, v_1, v_2, \dots, v_{n-1})</annotation></semantics></math>.</p>
<p>Often, however, there will be some level of indirection involved in
our use of the notation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mi>i</mi></msub><annotation encoding="application/x-tex">v_i</annotation></semantics></math>
for a coordinate of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐯</mi><annotation encoding="application/x-tex">\mathbf{v}</annotation></semantics></math>.
For example, if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐔</mi><annotation encoding="application/x-tex">\mathbf{U}</annotation></semantics></math>
is a proper subspace of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>n</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^n</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐔</mi><mo>=</mo><msup><mi>𝐑</mi><mi>U</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{U}
= \mathbf{R}^U</annotation></semantics></math> for some proper subset
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">n = \{0,1,\dots,n-1\}</annotation></semantics></math>,
then we may regard
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mi>i</mi></msub><annotation encoding="application/x-tex">u_i</annotation></semantics></math>
as the value taken by the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>th
member of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>
in some arbitrary but fixed ordering of the members of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>.
We even allow the case where the function domain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>
isn’t a set of integers at all but just some finite collection of
objects. In this case, in the context of considering vectors
(<em>qua</em> mappings)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐯</mi><mo>∈</mo><msup><mi>𝐑</mi><mi>U</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{v}\in \mathbf{R}^U</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mi>i</mi></msub><annotation encoding="application/x-tex">v_i</annotation></semantics></math>
may denote alternately the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>i</mi><mtext mathvariant="normal">th</mtext></msup><annotation encoding="application/x-tex">i^\text{th}</annotation></semantics></math>
member of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>
in some fixed enumeration; the name of a variable associated with that
member; or the value of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>i</mi><mtext mathvariant="normal">th</mtext></msup><annotation encoding="application/x-tex">i^\text{th}</annotation></semantics></math>
coordinate of some particular vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐯</mi><annotation encoding="application/x-tex">\mathbf{v}</annotation></semantics></math>.
In the later case,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mi>i</mi></msub><annotation encoding="application/x-tex">v_i</annotation></semantics></math>
doesn’t abbreviate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">v(i)</annotation></semantics></math>
for some function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><msup><mi>𝐑</mi><mi>U</mi></msup></mrow><annotation encoding="application/x-tex">v\in \mathbf{R}^U</annotation></semantics></math>.
Rather, it stands for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>u</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">v(u_i)</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mi>i</mi></msub><annotation encoding="application/x-tex">u_i</annotation></semantics></math>
denotes “the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>i</mi><mtext mathvariant="normal">th</mtext></msup><annotation encoding="application/x-tex">i^\text{th}</annotation></semantics></math>
member of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>.”</p>
<p>Any function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f: C \to B</annotation></semantics></math>
may be identified with the set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>c</mi><mo>,</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mo>:</mo><mspace width="0.167em"></mspace><mi>c</mi><mo>∈</mo><mi>C</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{(c,
f(c))\,:\,c\in C\}</annotation></semantics></math>. Thus, the target set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
is not an intrinsic part of the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>.
But, defining the <em>image set</em> of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
as <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>Im</mo><mi>f</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>b</mi><mspace width="0.167em"></mspace><mo>:</mo><mrow><mrow><mtext mathvariant="normal">there exists </mtext><mspace width="0.333em"></mspace></mrow><mrow><mi>c</mi><mo>∈</mo><mi>C</mi></mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> such that</mtext></mrow></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>c</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mi>f</mi><mo stretchy="false" form="postfix">}</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation*}
    \operatorname{Im}f = \{b\,: \text{there exists $c\in C$ such that} (c, b) \in f\},
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
we can at least say
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>Im</mo><mi>f</mi><mo>⊆</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\operatorname{Im}f\subseteq B</annotation></semantics></math>.</p>
<p>Given any function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f: C \to B</annotation></semantics></math>
and any subset
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>0</mn></msub><mo>⊆</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">C_0\subseteq C</annotation></semantics></math>,
we can define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">|</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">f|C_0</annotation></semantics></math>,
the <em>restriction of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mn>0</mn></msub><annotation encoding="application/x-tex">C_0</annotation></semantics></math></em>,
as <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">|</mo><msub><mi>C</mi><mn>0</mn></msub><mo>:=</mo><mo stretchy="false" form="prefix">{</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>c</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mi>f</mi><mspace width="0.167em"></mspace><mo>:</mo><mspace width="0.167em"></mspace><mi>c</mi><mo>∈</mo><msub><mi>C</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\begin{equation*}
    f|C_0 := \{(c, b) \in f\,:\,c\in C_0\}
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
We shall be particularly interested in restrictions of functions
specifying points in Euclidean space. Suppose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐱</mi><mo>∈</mo><msup><mi>𝐑</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{x}\in \mathbf{R}^n</annotation></semantics></math>,
and let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
be an arbitrary subset of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">n=\{0,1,2,\dots,n-1\}</annotation></semantics></math>.
Then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐱</mi><mo stretchy="false" form="prefix">|</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}|W</annotation></semantics></math>
will be a member of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>W</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^W</annotation></semantics></math>,
the set of functions that assign a real number to each member of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>.
We regard
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>W</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^W</annotation></semantics></math>
as a subspace of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>n</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^n</annotation></semantics></math>.
Moreover, if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
has
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
members,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>W</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^W</annotation></semantics></math>
will be isomorphic to, but not necessarily equal to, the Euclidean space
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>k</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^k</annotation></semantics></math>.
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>W</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^W</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>k</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^k</annotation></semantics></math>
are equal iff
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">W=k</annotation></semantics></math>
(that is, iff
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">W = \{0,
1, \dots, k-1\})</annotation></semantics></math>.) We define the
projection mapping
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>π</mi><mrow><mi>n</mi><mo>→</mo><mi>W</mi></mrow></msup><mo>:</mo><msup><mi>𝐑</mi><mi>n</mi></msup><mo>→</mo><msup><mi>𝐑</mi><mi>W</mi></msup></mrow><annotation encoding="application/x-tex">\pi^{n\to W}:
\mathbf{R}^n\to \mathbf{R}^W</annotation></semantics></math> by the rule
<!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>↦</mo><mi>v</mi><mo stretchy="false" form="prefix">|</mo><mi>W</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
    v \mapsto v|W.
\end{equation*}</annotation></semantics></math></p>
<p>More generally, given any two finite sets
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>⊆</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">W\subseteq U</annotation></semantics></math>
(not necessarily sets of integers), we may define a projection mapping
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>π</mi><mrow><mi>U</mi><mo>→</mo><mi>W</mi></mrow></msup><mo>:</mo><msup><mi>𝐑</mi><mi>U</mi></msup><mo>→</mo><msup><mi>𝐑</mi><mi>W</mi></msup></mrow><annotation encoding="application/x-tex">\pi^{U\to W}: \mathbf{R}^U\to \mathbf{R}^W</annotation></semantics></math>
by the rule <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><msup><mi>𝐑</mi><mi>U</mi></msup><mo>↦</mo><mi>v</mi><mo stretchy="false" form="prefix">|</mo><mi>W</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
   v \in \mathbf{R}^U \mapsto v|W.
\end{equation*}</annotation></semantics></math></p>
<p>Just as we can restrict the domain of a function, we can expand it as
well.</p>
<p>Suppose we have two functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∈</mo><msup><mi>𝐑</mi><mi>X</mi></msup></mrow><annotation encoding="application/x-tex">f\in\mathbf{R}^X</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∈</mo><msup><mi>𝐑</mi><mi>Y</mi></msup></mrow><annotation encoding="application/x-tex">g\in\mathbf{R}^Y</annotation></semantics></math>,
where either
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
are disjoint, or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(z) = g(z)</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>∈</mo><mi>X</mi><mo>∩</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">z\in X\cap Y</annotation></semantics></math>.
We define the <em>union</em>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∪</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f\cup g</annotation></semantics></math>
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>
by the rule <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo>∪</mo><mi>g</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mrow><mi>z</mi><mo>∈</mo><mi>X</mi></mrow><mtext mathvariant="normal">,</mtext></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mrow><mi>z</mi><mo>∈</mo><mi>Y</mi><mo>∖</mo><mi>X</mi></mrow><mtext mathvariant="normal">.</mtext></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{equation*}
    (f\cup g)(z) = \begin{cases}
           f(z) &amp; \text{if $z\in X$,} \\
           g(z) &amp; \text{if $z\in Y\smallsetminus X$.}
       \end{cases}
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
Note that this is exactly the same function as that we get by regarding
functions as sets of ordered pairs and then taking the literal (set)
union of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>.
Also, clearly, <!-- (no par break) --> <span class="math display">$$\begin{align*}
    f &amp;= (f\cup g)|X \\
    \intertext{and}
    g &amp;= (f\cup g)|Y.
\end{align*}$$</span></p>
<p>Lastly, given any two sets
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>,
we define the <em>Cartesian product</em> of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
to be a set of ordered couples:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:</mo><mi>a</mi><mo>∈</mo><mi>A</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and </mtext><mspace width="0.333em"></mspace></mrow><mi>b</mi><mo>∈</mo><mi>B</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\begin{equation*}
    A\times B = \{(a, b): a\in A \text{ and } b\in B\}
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><msup><mi>𝐑</mi><mi>X</mi></msup></mrow><annotation encoding="application/x-tex">A=\mathbf{R}^X</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><msup><mi>𝐑</mi><mi>Y</mi></msup></mrow><annotation encoding="application/x-tex">B=\mathbf{R}^Y</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>∩</mo><mi>Y</mi><mo>=</mo><mi>∅</mi></mrow><annotation encoding="application/x-tex">X\cap Y=\emptyset</annotation></semantics></math>,
then there is a natural isomorphism between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐑</mi><mi>X</mi></msup><mo>×</mo><msup><mi>𝐑</mi><mi>Y</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{R}^X\times\mathbf{R}^Y</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mrow><mi>X</mi><mo>∪</mo><mi>Y</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{R}^{X\cup Y}</annotation></semantics></math>
given by <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo>,</mo><mi>𝐲</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>↦</mo><mi>𝐱</mi><mo>∪</mo><mi>𝐲</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
    (\mathbf{x}, \mathbf{y}) \mapsto \mathbf{x}\cup\mathbf{y}.
\end{equation*}</annotation></semantics></math> (The inverse mapping is
given by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐯</mi><mo>↦</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐯</mi><mrow><mo stretchy="true" form="prefix">|</mo><mi>X</mi><mo>,</mo><mi>𝐯</mi><mo stretchy="true" form="postfix">|</mo></mrow><mi>Y</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{v} \mapsto (\mathbf{v}|X,
\mathbf{v}|Y)</annotation></semantics></math> for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐯</mi><mo>∈</mo><msup><mi>𝐑</mi><mrow><mi>X</mi><mo>∪</mo><mi>Y</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{v}\in \mathbf{R}^{X\cup Y}</annotation></semantics></math>.)
<!-- (no par break) --> Where convenient and warranted, we will consider
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐑</mi><mi>X</mi></msup><mo>×</mo><msup><mi>𝐑</mi><mi>Y</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{R}^X\times\mathbf{R}^Y</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mrow><mi>X</mi><mo>∪</mo><mi>Y</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{R}^{X\cup Y}</annotation></semantics></math>
identical.</p>
<p>The notion of Cartisean product can be extended to three or more
sets. For example, since there is a natural isomophism between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">(A\times
B)\times C</annotation></semantics></math> and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>B</mi><mo>×</mo><mi>C</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A\times(B\times C)</annotation></semantics></math>,
we can just write the product as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi><mo>×</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A\times B\times C</annotation></semantics></math>
and write its members as ordered triplets
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a,b,c)</annotation></semantics></math>
(instead of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">((a,b),c)</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(a,(b,c)</annotation></semantics></math>).</p>
</div>
<div class="section level3">
<h3 id="the-khalil-model">The Khalil model<a class="anchor" aria-label="anchor" href="#the-khalil-model"></a>
</h3>
<p>The first model we consider is that described by Khalil <span class="citation">(<a href="#ref-alma99454477012205899">Khalil
2002</a>)</span>. This model is both expressive and flexible, and we
believe it is the most intuitively natural way to view the sort of
systems BioCro deals with at the systems level (Section ).</p>
<p>In the opening chapter, the author introduces dynamical systems as a
finite collection of coupled first-order ordinary differential
equations</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mover><mi>x</mi><mo accent="true">̇</mo></mover><mn>0</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>f</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>u</mi><mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>u</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mover><mi>x</mi><mo accent="true">̇</mo></mover><mn>1</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>f</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>u</mi><mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>u</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mspace width="0.278em"></mspace><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mover><mi>x</mi><mo accent="true">̇</mo></mover><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>f</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>u</mi><mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>u</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
  \dot{x}_0 &amp;= f_0(t, x_0, \dots, x_{n-1}, u_0, \dots, u_{p-1}) \\
  \dot{x}_1 &amp;= f_1(t, x_0, \dots, x_{n-1}, u_0, \dots, u_{p-1}) \\
  &amp;\; \vdots \\
  \dot{x}_{n-1} &amp;= f_{n-1}(t, x_0, \dots, x_{n-1}, u_0, \dots, u_{p-1}).
\end{align*}</annotation></semantics></math></p>
<p>This is somewhat more general than the system we considered in
Section in that the derivatives depend not only upon the state variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_0, x_1, \dots, x_{n-1}</annotation></semantics></math>,
but also upon time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
and what Khalil refers to as the <em>input</em> variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mn>0</mn></msub><mo>,</mo><msub><mi>u</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>u</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">u_0, u_1, \dots, u_{p-1}</annotation></semantics></math>.</p>
<p>Defining <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐱</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>x</mi><mn>0</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>x</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>𝐮</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>u</mi><mn>0</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>u</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>u</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>𝐟</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>𝐱</mi><mo>,</mo><mi>𝐮</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>f</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>𝐱</mi><mo>,</mo><mi>𝐮</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>f</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>𝐱</mi><mo>,</mo><mi>𝐮</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>f</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>𝐱</mi><mo>,</mo><mi>𝐮</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation}
  \mathbf{x} = \begin{bmatrix}
                     x_0 \\
                     x_1 \\
                     \vdots \\
                     \vdots \\
                     x_{n-1}
               \end{bmatrix},\quad
  \mathbf{u} = \begin{bmatrix}
                     u_0 \\
                     u_1 \\
                     \vdots \\
                     \vdots \\
                     u_{p-1}
               \end{bmatrix},\quad
  \mathbf{f}(t, \mathbf{x}, \mathbf{u}) = \begin{bmatrix}
                     f_0(t, \mathbf{x}, \mathbf{u}) \\
                     f_1(t, \mathbf{x}, \mathbf{u}) \\
                     \vdots \\
                     \vdots \\
                     f_{n-1}(t, \mathbf{x}, \mathbf{u})
               \end{bmatrix}, \label{eq:khalil_vectors}
\end{equation}</annotation></semantics></math><!-- (no par break) -->
the state equation may be written more succinctly as the vector equation
<!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝐱</mi><mo accent="true">̇</mo></mover><mo>=</mo><mi>𝐟</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>𝐱</mi><mo>,</mo><mi>𝐮</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
  \dot{\mathbf{x}} = \mathbf{f}(t, \mathbf{x}, \mathbf{u}). \label{eq:Khalil_state_equation}
\end{equation}</annotation></semantics></math><!-- (no par break) -->
(Note that Khalil actually uses 1-based indexing of vector coordinates
in his exposition, so the vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>,
for example, is defined by <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐱</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>x</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>x</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>x</mi><mi>n</mi></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
  \mathbf{x} = \begin{bmatrix}
                     x_1 \\
                     x_2 \\
                     \vdots \\
                     \vdots \\
                     x_n
               \end{bmatrix}.
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
Here we use 0-based indexing instead in order to be consistent with
other parts of this article.)</p>
<div class="section level4">
<h4 id="variants-of-khalils-model">Variants of Khalil’s model<a class="anchor" aria-label="anchor" href="#variants-of-khalils-model"></a>
</h4>
<p>At this point, it is worth bringing up two restricted versions of the
Khalil model.</p>
<p>The first is when equation can be written as <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝐱</mi><mo accent="true">̇</mo></mover><mo>=</mo><mi>𝐟</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
  \dot{\mathbf{x}} = \mathbf{f}(t, \mathbf{x}). \label{eq:unforced_state_equation}
\end{equation}</annotation></semantics></math><!-- (no par break) -->
Khalil refers to this as the <em>unforced</em> state equation: it lacks
any explicit mention of inputs. But, he points out, if the input can be
specified as an explicit function of time, <!-- (no par break) --> <span class="math display">$$\begin{align}
  \mathbf{u} &amp;= \boldsymbol\gamma(t), \\
  \intertext{an explicit function of the state,}
  \mathbf{u} &amp;= \boldsymbol\gamma(\mathbf{x}), \\
  \intertext{or an explicit function of both,}
  \mathbf{u} &amp;= \boldsymbol\gamma(t, \mathbf{x}),
\end{align}$$</span> <!-- (no par break) --> then an equation of the
form can always be reduced to an equation of the form .</p>
<p>Khalil goes on to mention one particular special case of the class of
systems described by equation : namely, those that are
<em>autonomous</em> or <em>time-invariant</em>. A system is
<em>autonomous</em> if the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
does not depend explicitly on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
that is, if <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝐱</mi><mo accent="true">̇</mo></mover><mo>=</mo><mi>𝐟</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
  \dot{\mathbf{x}} = \mathbf{f}(\mathbf{x}). \label{eq:autonomous_state_equation}
\end{equation}</annotation></semantics></math><!-- (no par break) -->
The behavior of an autonomous system is invariant to shifts in time
origin. (Formally, however, as we shall see later in Section , a
non-autonomous system can be made into an automous one by introducing a
time-related variable into the state.)</p>
<p>The falling body system considered above was autonomous: the motion
of the body will follow the same pattern independent of when it is
released. On the other hand, most realistic biological models tend to be
non-autonomous or time-varying. This is largely due to the influence of
weather and other environmental factors; for example, it matters whether
seeds are sown in March or in May.</p>
</div>
</div>
<div class="section level3">
<h3 id="the-giunti-mazzola-model">The Giunti-Mazzola model <a class="anchor" aria-label="anchor" href="#the-giunti-mazzola-model"></a>
</h3>
<p>The model due to Giunti and Mazzola is a further generalization of
the autonomous version of the Khalil model, though cast in a somewhat
different form. Being autonomous, it is in some respects more
restrictive than the general model given in ; but in other respects it
is considerably more general.</p>
<p>We highlight this model for two reasons: First, it is mentioned in
the supplementary materials to <span class="citation">Lochocki et al.
(<a href="#ref-10.1093/insilicoplants/diac003">2022</a>)</span>. Second,
it generalizes the concept of time used for dynamical systems from the
real numbers (which the Khalil model assumes) to any monoid. In
particular, we may consider time domains consisting of the non-negative
integers, or some fixed multiple of the same, such as the non-negative
even integers. This is one of the natural ways to view time in
discrete-time systems, which often arise in practice because
continuous-time systems are discretized when applying numeric solution
methods (Section ).</p>
<p>We quote Giunti and Mazzola’s definition of a dynamical system
verbatim ( in <span class="citation">Giunti and Mazzola (<a href="#ref-Giunti&amp;Mazzola">2012</a>)</span>):</p>
<blockquote>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><msub><mi>S</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">DS_L</annotation></semantics></math>
is a dynamical system on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
iff
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><msub><mi>S</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">DS_L</annotation></semantics></math>
is a pair
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>M</mi><mo>,</mo><msub><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>g</mi><mi>t</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>t</mi><mo>∈</mo><mi>T</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(M,(g^t)_{t \in T})</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
is a pair
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mo>,</mo><mo>+</mo><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(T, +)</annotation></semantics></math>
such that</p>
<ol style="list-style-type: lower-roman">
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mo>,</mo><mo>+</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">L = (T, +)</annotation></semantics></math>
is a monoid. Any
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t \in T</annotation></semantics></math>
is called a <em>duration</em> of the system,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
is called its <em>time set</em>, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
its <em>time model</em>;</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
is a non-empty set. Any
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">x \in M</annotation></semantics></math>
is called a <em>state</em> of the system, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
is called its <em>state space</em>;</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>g</mi><mi>t</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>t</mi><mo>∈</mo><mi>T</mi></mrow></msub><annotation encoding="application/x-tex">(g^t)_{t \in T}</annotation></semantics></math>
is a family indexed by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
of functions from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>.
For any
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t\in T</annotation></semantics></math>,
the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>g</mi><mi>t</mi></msup><annotation encoding="application/x-tex">g^t</annotation></semantics></math>
is called the <em>state transition of duration
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math></em>
(briefly,
<em><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>-transition</em>,
or
<em><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>-advance</em>)
of the system;</p></li>
<li>
<p>for any
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>,</mo><mi>t</mi><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">v,t\in T</annotation></semantics></math>,
for any
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">x\in M</annotation></semantics></math>,</p>
<ol style="list-style-type: lower-alpha">
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mn>0</mn></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">g^0(x) = x</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
is the unity of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>;</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mrow><mi>v</mi><mo>+</mo><mi>t</mi></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>g</mi><mi>v</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>g</mi><mi>t</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">g^{v+t}(x) = g^v(g^t(x))</annotation></semantics></math>.</p></li>
</ol>
</li>
</ol>
</blockquote>
<p> Notice that not only can the time model now be any monoid, the state
space can now be any non-empty set: it is no longer required to be a
subset of a Euclidean space. It needn’t even be a continuum! <em>A
fortiori</em>, there is no longer any requirement that the state
transitions be differential equation based.</p>
<p>Instead of differential equations, we have condition (iv.b),
sometimes called the <em>semi-group</em> property, which relates the
structure of the time model to that of the class of state transitions.
Just as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
is a monoid with operation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math>
and additive identity
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>,
so too is the collection
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>g</mi><mi>t</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>t</mi><mo>∈</mo><mi>T</mi></mrow></msub><annotation encoding="application/x-tex">(g^t)_{t \in T}</annotation></semantics></math>
of state transitions, with the monoid operation being function
composition and the identity element being the identity function.
Condition (iv) asserts that the mapping from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mo>,</mo><mo>+</mo><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(T, +)</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>g</mi><mi>t</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>t</mi><mo>∈</mo><mi>T</mi></mrow></msub><mo>,</mo><mo>∘</mo><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">((g^t)_{t \in T}, \circ)</annotation></semantics></math>
whereby
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>↦</mo><msup><mi>g</mi><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">t \mapsto g^t</annotation></semantics></math>
is a monoid homomorphism.</p>
<p>Condition (iv) is in fact the crux of this definition of a dynamical
system. Without it, there is no structure to the way in which such a
system evolves: the system may pass from one state to the next
willy-nilly without any constraint on the relationship between states
over time.</p>
</div>
<div class="section level3">
<h3 id="the-barreira-valls-model">The Barreira-Valls model<a class="anchor" aria-label="anchor" href="#the-barreira-valls-model"></a>
</h3>
<p>We briefly mention one further model for the discrete time case,
mainly because the formulation is the epitome of simplicity.
<em>Definition 1.1</em> in <span class="citation">Barreira (<a href="#ref-alma99954905266605899">2019</a>)</span> states simply</p>
<blockquote>
<p><em>A map
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>𝐗</mi><mo>→</mo><mi>𝐗</mi></mrow><annotation encoding="application/x-tex">f: \mathbf{X}\to\mathbf{X}</annotation></semantics></math>
is called a</em> dynamical system <em>with discrete time.</em></p>
</blockquote>
<p> The definition goes on to define higher-order mappings:</p>
<blockquote>
<p><em>We define recursively</em></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mi>n</mi></msup><mo>=</mo><mi>f</mi><mo>∘</mo><msup><mi>f</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\begin{equation*}
    f^n = f\circ f^{n-1}
\end{equation*}</annotation></semantics></math></p>
<p><em>for each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><msup><mi>𝐙</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">n\in\mathbf{Z}^+</annotation></semantics></math>,
with the convention that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mn>0</mn></msup><mo>=</mo><mo>id</mo></mrow><annotation encoding="application/x-tex">f^0 = \operatorname{id}</annotation></semantics></math>.
When
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
is invertible, we also define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mi>n</mi></mrow></msup><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">f^{-n} = (f^{-1})^n</annotation></semantics></math>
for each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><msup><mi>𝐙</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">n\in\mathbf{Z}^+</annotation></semantics></math>.</em></p>
</blockquote>
<p> This is entirely homologous to the Giunti-Mazzola model for the case
where the monoid chosen for the time model is either
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐙</mi><annotation encoding="application/x-tex">\mathbf{Z}</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐍</mi><annotation encoding="application/x-tex">\mathbf{N}</annotation></semantics></math>.</p>
<p>Note that the recursion equation derived from applying Euler’s method
to the falling body problem fits nicely into this model: take
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math>
to be Euclidean 2-space and the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
to be defined by the rule</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>↦</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>+</mo><mi>δ</mi><mi>y</mi><mo>,</mo><mi>y</mi><mo>−</mo><mi>δ</mi><mi>g</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
    (x, y) \mapsto (x + \delta y, y - \delta g).
\end{equation*}</annotation></semantics></math></p>
<p>(Barreira and Valls go on to define “a dynamical system <em>with
continuous time</em>” <span class="citation">(<a href="#ref-alma99954905266605899">Barreira 2019</a>, Definition
1.7)</span> in precisely the same way as Giunti and Mazzola (for the
case where the time model is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐑</mi><annotation encoding="application/x-tex">\mathbf{R}</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐑</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub><annotation encoding="application/x-tex">\mathbf{R}_{\geq 0}</annotation></semantics></math>)—that
is, as a family of mappings indexed by time satisfying the semi-group
property.)</p>
</div>
</div>
<div class="section level2">
<h2 id="the-biocro-model">The BioCro model <a class="anchor" aria-label="anchor" href="#the-biocro-model"></a>
</h2>
<p>A BioCro system is determined by the specification of five
entities:</p>
<ol style="list-style-type: decimal">
<li>A set of initial values</li>
<li>A set of (constant) parameter values</li>
<li>A set of drivers</li>
<li>A set of direct modules</li>
<li>A set of differential modules</li>
</ol>
<p> These five entities tell us everything about the dynamics of the
system that we need in order to “solve” it. (How, precisely, it will be
solved is determined by specifying a solver.)<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;A less rigorous but much more succinct overview of the
BioCro model is given in Appendix 2 of &lt;span class="citation"&gt;Lochocki
et al. (&lt;a href="#ref-10.1093/insilicoplants/diac003"&gt;2022&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;'><sup>3</sup></a></p>
<p>Aside from differences in the concept of <em>state</em> (Section ),
the Khalil model fits very well with an idealized version of the BioCro
model in which time is considered to be continuous.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;There are rare cases where a BioCro model uses a module
corresponding to a difference equation rather than a differential
equation. Such models assume discrete time steps and are not naturally
viewed as simply discretizations of systems of ordinary differential
equations. They correspond to a variant of the Khalil model in which the
state equation (Equation ) has been replaced with the difference
equation
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;Δ&lt;/mi&gt;&lt;mi&gt;𝐱&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;𝐟&lt;/mi&gt;&lt;mrow&gt;&lt;mo stretchy="true" form="prefix"&gt;(&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;𝐱&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;𝐮&lt;/mi&gt;&lt;mo stretchy="true" form="postfix"&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding="application/x-tex"&gt;\Delta\mathbf{x} = \mathbf{f}(t, \mathbf{x},
\mathbf{u})&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;. Since these modules are
rare, and since we hope to eventually phase them out of the standard
BioCro module library, we won’t consider such modules further.&lt;/p&gt;'><sup>4</sup></a> We will see this in
the section , where we discuss the two models side-by-side. But first,
we must elaborate a bit further on the Khalil model.</p>
<div class="section level3">
<h3 id="elaboration-on-the-khalil-model">Elaboration on the Khalil model <a class="anchor" aria-label="anchor" href="#elaboration-on-the-khalil-model"></a>
</h3>
<p>Recall that the Khalil model expresses the derivative
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>𝐱</mi><mi>/</mi><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">d\mathbf{x}/dt</annotation></semantics></math>
of the state as a function of time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
the state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>,
and the input
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐮</mi><annotation encoding="application/x-tex">\mathbf{u}</annotation></semantics></math>:
<!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝐱</mi><mo accent="true">̇</mo></mover><mo>=</mo><mi>𝐟</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>𝐱</mi><mo>,</mo><mi>𝐮</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
  \dot{\mathbf{x}} = \mathbf{f}(t, \mathbf{x}, \mathbf{u}).
\end{equation*}</annotation></semantics></math></p>
<p>Let us denote the domains of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐮</mi><annotation encoding="application/x-tex">\mathbf{u}</annotation></semantics></math>
(vis-à-vis the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐟</mi><annotation encoding="application/x-tex">\mathbf{f}</annotation></semantics></math>)
by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐔</mi><annotation encoding="application/x-tex">\mathbf{U}</annotation></semantics></math>.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐔</mi><annotation encoding="application/x-tex">\mathbf{U}</annotation></semantics></math>
are vector spaces over the reals, and following the conventions set out
in Section , we may view them as sets of mappings from finite
<em>index</em> sets into the reals. Thus <!-- (no par break) --> <span class="math display">$$\begin{align}
    \mathbf{X} = \mathbf{R}^X \\
    \intertext{and}
    \mathbf{U} = \mathbf{R}^U
\end{align}$$</span> <!-- (no par break) --> for some finite sets
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>,
where we assume
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>
are disjoint.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;If
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy=&quot;false&quot; form=&quot;postfix&quot;&gt;∥&lt;/mo&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot; form=&quot;postfix&quot;&gt;∥&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\|X\|=n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
and
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy=&quot;false&quot; form=&quot;postfix&quot;&gt;∥&lt;/mo&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot; form=&quot;postfix&quot;&gt;∥&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\|U\|=p&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;,
then
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;msup&gt;&lt;mi&gt;𝐑&lt;/mi&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;/msup&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf{R}^X&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
is isomorphic to the Euclidean space
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;msup&gt;&lt;mi&gt;𝐑&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msup&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf{R}^n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
and
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;msup&gt;&lt;mi&gt;𝐑&lt;/mi&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;/msup&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf{R}^U&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
is isomorphic to
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;msup&gt;&lt;mi&gt;𝐑&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/msup&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf{R}^p&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;.
In many contexts, we could just go ahead and consider them not just
isomorphic but identical. But here we want to be more careful because we
want to be able to simultaneously consider functions into
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mi&gt;𝐑&lt;/mi&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf{R}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
having non-overlapping domains.&lt;/p&gt;
&lt;p&gt;Note that in practice, in a model of a real-world system,
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mi&gt;𝐟&lt;/mi&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf{f}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
may not be defined for all
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;𝐱&lt;/mi&gt;&lt;mo&gt;∈&lt;/mo&gt;&lt;mi&gt;𝐗&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf{x}\in\mathbf{X}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
and all
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;𝐮&lt;/mi&gt;&lt;mo&gt;∈&lt;/mo&gt;&lt;mi&gt;𝐔&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf{u}\in\mathbf{U}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;.
A coordinate corresponding to temperature in degrees Kelvin, for
example, can not meaningfully take on values less than zero. In general,
however,
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mi&gt;𝐟&lt;/mi&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf{f}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
will be defined for all
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;𝐱&lt;/mi&gt;&lt;mo&gt;∈&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;𝐗&lt;/mi&gt;&lt;mi mathvariant=&quot;bold&quot;&gt;′&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf{x}\in\mathbf{X'}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
and all
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;𝐮&lt;/mi&gt;&lt;mo&gt;∈&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;𝐔&lt;/mi&gt;&lt;mi mathvariant=&quot;bold&quot;&gt;′&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf{u}\in\mathbf{U'}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
where
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;𝐗&lt;/mi&gt;&lt;mi mathvariant=&quot;bold&quot;&gt;′&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf{X'}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
and
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;𝐔&lt;/mi&gt;&lt;mi mathvariant=&quot;bold&quot;&gt;′&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf{U'}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
are connected subsets of
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mi&gt;𝐗&lt;/mi&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf{X}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
and
&lt;math display=&quot;inline&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mi&gt;𝐔&lt;/mi&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf{U}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;.
We will reconsider this issue in Section .&lt;/p&gt;"><sup>5</sup></a></p>
<p>Furthermore, recall that in the Khalil model, the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐮</mi><annotation encoding="application/x-tex">\mathbf{u}</annotation></semantics></math>
may given by some function of time and/or the state:
<!-- (no par break) --> <span class="math display">$$\begin{align*}
  \mathbf{u} &amp;= \boldsymbol\gamma(t), \\
  \mathbf{u} &amp;= \boldsymbol\gamma(\mathbf{x}), \\
  \intertext{or}
  \mathbf{u} &amp;= \boldsymbol\gamma(t, \mathbf{x}).
\end{align*}$$</span> <!-- (no par break) --> Thinking in terms of the
individual components of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐮</mi><annotation encoding="application/x-tex">\mathbf{u}</annotation></semantics></math>,
each component
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mi>i</mi></msub><annotation encoding="application/x-tex">u_i</annotation></semantics></math>
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐮</mi><annotation encoding="application/x-tex">\mathbf{u}</annotation></semantics></math>
can be expressed as a function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>γ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\gamma_i</annotation></semantics></math>
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>
or both: <!-- (no par break) --> <span class="math display">$$\begin{align*}
  u_i &amp;= \gamma_i(t), \\
  u_i &amp;= \gamma_i(\mathbf{x}), \\
  \intertext{or}
  u_i &amp;= \gamma_i(t, \mathbf{x}).
\end{align*}$$</span> <!-- (no par break) --> It is also possible that
some
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mi>i</mi></msub><annotation encoding="application/x-tex">u_i</annotation></semantics></math>
doesn’t actually depend on either time or state, that it is in fact
constant: <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub><mo>=</mo><mi>k</mi><mspace width="1.0em"></mspace><mrow><mrow><mtext mathvariant="normal">for some </mtext><mspace width="0.333em"></mspace></mrow><mrow><mi>k</mi><mo>∈</mo><mi>𝐑</mi></mrow></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
  u_i = k \quad \text{for some $k\in\mathbf{R}$}.
\end{equation}</annotation></semantics></math><!-- (no par break) -->
We can, in fact, partition the variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mn>0</mn></msub><mo>,</mo><msub><mi>u</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>u</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">u_0, u_1, \dots, u_{p-1}</annotation></semantics></math>
comprising the varying input
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐮</mi><annotation encoding="application/x-tex">\mathbf{u}</annotation></semantics></math>
into three groups:</p>
<ol style="list-style-type: decimal">
<li><p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mi>i</mi></msub><annotation encoding="application/x-tex">u_i</annotation></semantics></math>
be in group
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
if the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mi>i</mi></msub><annotation encoding="application/x-tex">u_i</annotation></semantics></math>
depends on neither
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
nor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>;
that is, it always has the same value, no matter what the state or the
time.</p></li>
<li><p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mi>i</mi></msub><annotation encoding="application/x-tex">u_i</annotation></semantics></math>
be in group
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
if the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mi>i</mi></msub><annotation encoding="application/x-tex">u_i</annotation></semantics></math>
depends on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
alone.</p></li>
<li><p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mi>i</mi></msub><annotation encoding="application/x-tex">u_i</annotation></semantics></math>
be in group
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
otherwise, that is if the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mi>i</mi></msub><annotation encoding="application/x-tex">u_i</annotation></semantics></math>
depends on the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>
(and possibly also on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>).</p></li>
</ol>
<p> Thus
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><mi>K</mi><mo>∪</mo><mi>D</mi><mo>∪</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">U=K\cup D\cup W</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
are pairwise disjoint. This allows us to partition the vector space
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐔</mi><annotation encoding="application/x-tex">\mathbf{U}</annotation></semantics></math>
into corresponding sub-vector spaces
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐊</mi><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐖</mi><annotation encoding="application/x-tex">\mathbf{W}</annotation></semantics></math>;
that is, <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐔</mi><mo>=</mo><mi>𝐊</mi><mo>×</mo><mi>𝐃</mi><mo>×</mo><mi>𝐖</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation*}
  \mathbf{U} = \mathbf{K}\times\mathbf{D}\times\mathbf{W},
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐊</mi><mo>=</mo><msup><mi>𝐑</mi><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{K}=\mathbf{R}^K</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐃</mi><mo>=</mo><msup><mi>𝐑</mi><mi>D</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{D}=\mathbf{R}^D</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐖</mi><mo>=</mo><msup><mi>𝐑</mi><mi>W</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{W} = \mathbf{R}^W</annotation></semantics></math>.
Each input
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐮</mi><annotation encoding="application/x-tex">\mathbf{u}</annotation></semantics></math>
may now be written as a triplet
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐤</mi><mo>,</mo><mi>𝐝</mi><mo>,</mo><mi>𝐰</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{k}, \mathbf{d},
\mathbf{w})</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐤</mi><mo>∈</mo><mi>𝐊</mi></mrow><annotation encoding="application/x-tex">\mathbf{k}\in \mathbf{K}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐝</mi><mo>∈</mo><mi>𝐃</mi></mrow><annotation encoding="application/x-tex">\mathbf{d}\in \mathbf{D}</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐰</mi><mo>∈</mo><mi>𝐖</mi></mrow><annotation encoding="application/x-tex">\mathbf{w}\in \mathbf{W}</annotation></semantics></math>.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;Note that any (or all!) of the sets
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;annotation encoding="application/x-tex"&gt;K&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;,
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;annotation encoding="application/x-tex"&gt;D&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;,
or
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;annotation encoding="application/x-tex"&gt;W&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
may be empty, in which case the corresponding vector space is zero
dimensional and the corresponding vector argument can be eliminated from
equation . (If all three sets are empty, then of course we have no
inputs and the system is automatically described by the unforced state
equation .)&lt;/p&gt;'><sup>6</sup></a> Moreover,
there exist functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>γ</mi><mi>𝐃</mi></msup><mo>:</mo><mi>T</mi><mo>→</mo><mi>𝐃</mi></mrow><annotation encoding="application/x-tex">\gamma^\mathbf{D}: T\to\mathbf{D}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>γ</mi><mi>𝐖</mi></msup><mo>:</mo><mi>T</mi><mo>×</mo><mi>𝐗</mi><mo>→</mo><mi>𝐖</mi></mrow><annotation encoding="application/x-tex">\gamma^\mathbf{W}:
T\times\mathbf{X}\to\mathbf{W}</annotation></semantics></math> and a
constant function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>γ</mi><mi>𝐊</mi></msup><annotation encoding="application/x-tex">\gamma^\mathbf{K}</annotation></semantics></math>
with codomain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐊</mi><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math>
such that <!-- (no par break) --> <span class="math display">$$\begin{align}
  \mathbf{k} &amp;= \gamma^\mathbf{K}(),       \label{eq:k} \\
  \mathbf{d} &amp;= \gamma^\mathbf{D}(t),      \label{eq:d} \\
  \intertext{and}
  \mathbf{w} &amp;= \gamma^\mathbf{W}(t, \mathbf{x}) \label{eq:s}
\end{align}$$</span> <!-- (no par break) --> at any moment in the life
of the system.</p>
<p>Since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐮</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐤</mi><mo>,</mo><mi>𝐝</mi><mo>,</mo><mi>𝐰</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{u} = (\mathbf{k}, \mathbf{d}, \mathbf{w})</annotation></semantics></math>,
we can rewrite the state equation as <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝐱</mi><mo accent="true">̇</mo></mover><mo>=</mo><mi>𝐟</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>𝐱</mi><mo>,</mo><mi>𝐤</mi><mo>,</mo><mi>𝐝</mi><mo>,</mo><mi>𝐰</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
  \dot{\mathbf{x}} = \mathbf{f}(t, \mathbf{x}, \mathbf{k}, \mathbf{d}, \mathbf{w}). \label{eq:BioCro_state_equation}
\end{equation}</annotation></semantics></math><!-- (no par break) -->
But using equations , , and , we can eliminate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐤</mi><annotation encoding="application/x-tex">\mathbf{k}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐝</mi><annotation encoding="application/x-tex">\mathbf{d}</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐰</mi><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math>
to get
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐟</mi><annotation encoding="application/x-tex">\mathbf{f}</annotation></semantics></math>
as a function of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>
alone: <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝐱</mi><mo accent="true">̇</mo></mover><mo>=</mo><mi>𝐟</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>𝐱</mi><mo>,</mo><msup><mi>γ</mi><mi>𝐊</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msup><mi>γ</mi><mi>𝐃</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msup><mi>γ</mi><mi>𝐖</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
  \dot{\mathbf{x}} = \mathbf{f}(t, \mathbf{x}, \gamma^\mathbf{K}(), \gamma^\mathbf{D}(t), \gamma^\mathbf{W}(t, \mathbf{x})).
\end{equation}</annotation></semantics></math><!-- (no par break) -->
In other words, <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝐱</mi><mo accent="true">̇</mo></mover><mo>=</mo><msup><mi>𝐟</mi><mrow><mspace width="0.167em"></mspace><mo>*</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}
  \dot{\mathbf{x}} = \mathbf{f}^{\,*}(t, \mathbf{x})
\end{equation}</annotation></semantics></math><!-- (no par break) -->
for some suitable function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐟</mi><mrow><mspace width="0.167em"></mspace><mo>*</mo></mrow></msup><annotation encoding="application/x-tex">\mathbf{f}^{\,*}</annotation></semantics></math>,
so that we have now an unforced state equation as in equation .</p>
</div>
<div class="section level3">
<h3 id="biocro-viewed-in-terms-of-the-khalil-model">BioCro viewed in terms of the Khalil model <a class="anchor" aria-label="anchor" href="#biocro-viewed-in-terms-of-the-khalil-model"></a>
</h3>
<p>In BioCro, as noted above, a system is determined when we specify its
<em>initial values</em>, <em>parameters</em>, <em>drivers</em>,
<em>direct modules</em>, and <em>differential modules</em>. How do these
relate to the version of the Khalil model just discussed?</p>
<ul>
<li>The <em>initial values</em> correspond to the state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>
at some initial time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>0</mn></msub><annotation encoding="application/x-tex">t_0</annotation></semantics></math>,
which for convenience, we will always take to be 0. (Thus <em>time</em>
is always the amount of time that has elapsed since the start of the
simulation.) We will denote this initial state as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐱</mi><mn>0</mn></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mrow><mn>0</mn><mo>,</mo><mn>0</mn></mrow></msub><mo>,</mo><msub><mi>x</mi><mrow><mn>1</mn><mo>,</mo><mn>0</mn></mrow></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mo>,</mo><mn>0</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{x}_0 = (x_{0,0}, x_{1,0}, \dots, x_{n-1,0})</annotation></semantics></math>.
In BioCro, the state variables are referred to as <em>differential
quantities</em>, since they evolve according to differential equations.
It is the <em>initial values</em> specification that determines which
variables comprise the state, and the dimension of the state space
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math>
is equal to the number of variables in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐱</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\mathbf{x}_0</annotation></semantics></math>.</li>
</ul>
<p>For now, we shall consider the initial values as part of the
definition of a system only in so far as they determine the set of
variables comprising the state space for the system. The specification
of what values these variables have at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>0</mn></msub><annotation encoding="application/x-tex">t_0</annotation></semantics></math>
will be considered to be something associated with a particular run of a
system and not something inherent in the system itself. This will make
comparison with the Khalil and Giunti models easier, since those models
don’t specify anything analogous to an initial state.</p>
<p>In what follows, when we need to make this distinction, we shall
refer to a dynamical system together with a specified initial state as a
<em>run</em> of a system. It should also be noted, as discussed in
Section , that actually running the system (that is, allowing the state
to evolve from its initial values) requires the use of numerical methods
that effectively discretize the continous system of differential
equations of a Khalil system. Whether we consider this as the
development of a new discrete dynamical system from a continuous one or
just a matter of practical convenience is mostly matter of
perspective.</p>
<ul>
<li><p>The <em>parameters</em> correspond to the sole value in the
codomain of the constant function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>γ</mi><mi>𝐊</mi></msup><annotation encoding="application/x-tex">\gamma^\mathbf{K}</annotation></semantics></math>.
This will be a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>-tuple
of values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐤</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>k</mi><mn>0</mn></msub><mo>,</mo><msub><mi>k</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>k</mi><mrow><mi>q</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{k} = (k_0, k_1, \dots, k_{q-1})</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>
is the number of parameters, the dimension of the vector subspace
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐊</mi><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math>.</p></li>
<li><p>The <em>drivers</em> correspond to the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>γ</mi><mi>𝐃</mi></msup><mo>:</mo><mi>T</mi><mo>→</mo><msup><mi>𝐑</mi><mi>r</mi></msup></mrow><annotation encoding="application/x-tex">\gamma^\mathbf{D}:T\to\mathbf{R}^r</annotation></semantics></math>,
giving the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐝</mi><annotation encoding="application/x-tex">\mathbf{d}</annotation></semantics></math>
as a function of time. Writing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐝</mi><annotation encoding="application/x-tex">\mathbf{d}</annotation></semantics></math>
as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>d</mi><mn>0</mn></msub><mo>,</mo><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>d</mi><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(d_0, d_1, \dots, d_{r-1})</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math>
is the number of driver variables (the dimension of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>),
we can decompose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>γ</mi><mi>𝐃</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\gamma^\mathbf{D}(t)</annotation></semantics></math>
into scalar-valued functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>γ</mi><mn>0</mn><mi>𝐃</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\gamma^\mathbf{D}_0(t)</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>γ</mi><mn>1</mn><mi>𝐃</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\gamma^\mathbf{D}_1(t)</annotation></semantics></math>,
,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>γ</mi><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow><mi>𝐃</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\gamma^\mathbf{D}_{r-1}(t)</annotation></semantics></math>.</p></li>
</ul>
<p>It should be noted that the driver functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>γ</mi><mi>i</mi><mi>𝐃</mi></msubsup><annotation encoding="application/x-tex">\gamma^\mathbf{D}_i</annotation></semantics></math>
are rarely functions that can easily be specified by and computed from
some formula. In example shown in Appendix 1 of <span class="citation">Lochocki et al. (<a href="#ref-10.1093/insilicoplants/diac003">2022</a>)</span>, the
function giving the value of the driver variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
corresponding to photosynthetic photon flux density is based on the
function <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mo>sin</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>t</mi><mrow><mn>12</mn><mo>⋅</mo><mn>3600</mn></mrow></mfrac><mi>π</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><mn>2000</mn><mo>×</mo><msup><mn>10</mn><mrow><mo>−</mo><mn>6</mn></mrow></msup><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
  Q = \sin(\frac{t}{12\cdot 3600} \pi)\cdot 2000 \times 10^{-6}.
\end{equation}</annotation></semantics></math><!-- (no par break) -->
Here,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
is meant to represent the elapsed time in seconds, and in this example,
the actual values fed into the BioCro system constructor are only the
values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
for a set of integral values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
namely,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi>…</mi><mo>,</mo><mn>43200</mn></mrow><annotation encoding="application/x-tex">t = 0, 1, 2, \dots, 43200</annotation></semantics></math>.
As acknowledged in the appendix, this is a highly artificial
example.</p>
<p>Usually, a driver variable function can only be defined via an
equation<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;This particular function is, in fact, the function you
would get if you expressed the total PAR flux density (in
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;μ&lt;/mi&gt;&lt;mtext mathvariant="normal"&gt;mol&lt;/mtext&gt;&lt;mi&gt;/&lt;/mi&gt;&lt;msup&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mi&gt;/&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding="application/x-tex"&gt;\mu\text{mol}/m^2/s&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;)
measured at the Earth’s surface in Champaign, Illinois (per the
&lt;em&gt;weather&lt;/em&gt; data set accompanying BioCro) as a function (taking
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding="application/x-tex"&gt;t_i = i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;)
of the number of hours elapsed since midnight on January 1, 2005.&lt;/p&gt;'><sup>7</sup></a>
of the form <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>γ</mi><mi>i</mi><mi>𝐃</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mn>0.046</mn></mtd><mtd columnalign="left" style="text-align: left"><mrow><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mrow><mi>t</mi><mo>=</mo><msub><mi>t</mi><mn>0</mn></msub></mrow></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>0.023</mn></mtd><mtd columnalign="left" style="text-align: left"><mrow><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mrow><mi>t</mi><mo>=</mo><msub><mi>t</mi><mn>1</mn></msub></mrow></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mi>…</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mi>…</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>1151.541</mn></mtd><mtd columnalign="left" style="text-align: left"><mrow><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mrow><mi>t</mi><mo>=</mo><msub><mi>t</mi><mn>4000</mn></msub></mrow></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>747.040</mn></mtd><mtd columnalign="left" style="text-align: left"><mrow><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mrow><mi>t</mi><mo>=</mo><msub><mi>t</mi><mn>4001</mn></msub></mrow></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mi>…</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mi>…</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>0.621</mn></mtd><mtd columnalign="left" style="text-align: left"><mrow><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mrow><mi>t</mi><mo>=</mo><msub><mi>t</mi><mn>8758</mn></msub></mrow></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>0.874</mn></mtd><mtd columnalign="left" style="text-align: left"><mrow><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mrow><mi>t</mi><mo>=</mo><msub><mi>t</mi><mn>8759</mn></msub></mrow></mrow><mi>.</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}
    \gamma^\mathbf{D}_i(t) = \begin{cases}
        0.046 &amp; \text{if $t = t_0$}, \\
        0.023 &amp; \text{if $t = t_1$}, \\
        \dots \\
        \dots \\
        1151.541 &amp; \text{if $t = t_{4000}$}, \\
        747.040 &amp; \text{if $t = t_{4001}$}, \\
        \dots \\
        \dots \\
        0.621 &amp; \text{if $t = t_{8758}$}, \\
        0.874 &amp; \text{if $t = t_{8759}$}.
    \end{cases}
\end{equation}</annotation></semantics></math><!-- (no par break) -->
Here,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub><mo>,</mo><msub><mi>t</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>t</mi><mn>8759</mn></msub></mrow><annotation encoding="application/x-tex">t_0, t_1, \dots, t_{8759}</annotation></semantics></math>
is a sequence of times representing the amount of time elapsed since the
beginning of the simulation, with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t_0 = 0</annotation></semantics></math>,
and for some fixed positive value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>t</mi><mi>j</mi></msub><mo>+</mo><mi>Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">t_{j+1} =
t_j + \Delta t</annotation></semantics></math> for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mn>8759</mn></mrow><annotation encoding="application/x-tex">0 \leq j &lt; 8759</annotation></semantics></math>.
In practice, in BioCro, this equation is usually specified implicitly
via an R data frame:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>γ</mi><mi>i</mi><mi>𝐃</mi></msubsup><annotation encoding="application/x-tex">\gamma^\mathbf{D}_i</annotation></semantics></math>
corresponds to some column of the data frame, and the value of that
column in row
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
is that value for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>γ</mi><mi>i</mi><mi>𝐃</mi></msubsup><annotation encoding="application/x-tex">\gamma^\mathbf{D}_i</annotation></semantics></math>
at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">t_{j-1}</annotation></semantics></math>.</p>
<p>(For some numerical methods, we need to know values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>γ</mi><mi>i</mi><mi>𝐃</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\gamma^\mathbf{D}_i(t)</annotation></semantics></math>
for values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math><em>between</em> the time points given in this definition. In principle,
many approaches are available for this type of interpolation, such as
cubic splines. At the moment, BioCro only offers linear interpolation
between neighboring time points. In other words, an additional case is
added to the above rule: <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>γ</mi><mi>i</mi><mi>𝐃</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><msub><mi>t</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>t</mi></mrow><mrow><mi>Δ</mi><mi>t</mi></mrow></mfrac><mspace width="0.167em"></mspace><msubsup><mi>γ</mi><mi>i</mi><mi>𝐃</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mfrac><mrow><mi>t</mi><mo>−</mo><msub><mi>t</mi><mi>j</mi></msub></mrow><mrow><mi>Δ</mi><mi>t</mi></mrow></mfrac><mspace width="0.167em"></mspace><msubsup><mi>γ</mi><mi>i</mi><mi>𝐃</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="1.0em"></mspace><mrow><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mrow><msub><mi>t</mi><mi>j</mi></msub><mo>&lt;</mo><mi>t</mi><mo>&lt;</mo><msub><mi>t</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}
  \gamma^\mathbf{D}_i(t) = \frac{t_{j + 1} - t}{\Delta t}\,\gamma^\mathbf{D}_i(t_j)
                       + \frac{t - t_j}{\Delta t}\,\gamma^\mathbf{D}_i(t_{j+1})
                       \quad\text{if $t_j &lt; t &lt; t_{j+1}$}
\end{equation}</annotation></semantics></math><!-- (no par break) -->
This makes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>γ</mi><mi>i</mi><mi>𝐃</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\gamma^\mathbf{D}_i(t)</annotation></semantics></math>
into a piecewise-linear continuous function.)</p>
<p>Now to the modules. As we will show later (Section ), any BioCro
system is equivalent to a BioCro system having only a single module of
each type, but having the same initial values, parameters, and
drivers.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;This isn’t to say the requisite modules exist. In order
to realize this replacement, the user may have to write them!&lt;/p&gt;"><sup>8</sup></a>
Thus, for simplicity, we will here consider only the case where there is
a single module of each type.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;As an alternative to confining the discussion here to
the case where there is only a single module of each type, we could
instead make no stipulation about the number of modules and simply
substitute the phrase “the direct (differential) module component” in
every place where we speak of “the direct (differential) module”.&lt;/p&gt;"><sup>9</sup></a> Later, we will consider how a single module
may be broken up into multiple modules (Section ).</p>
<ul>
<li>
<p>The <em>direct module</em> corresponds to the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>γ</mi><mi>𝐖</mi></msup><mo>:</mo><mi>T</mi><mo>×</mo><mi>𝐗</mi><mo>→</mo><mi>𝐖</mi></mrow><annotation encoding="application/x-tex">\gamma^\mathbf{W}:
T\times\mathbf{X} \to \mathbf{W}</annotation></semantics></math>. In
point of fact, we usually think of the direct module as corresponding to
a function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mo>*</mo></msup><msup><mi>γ</mi><mi>𝐖</mi></msup><mo>:</mo><mi>𝐗</mi><mo>×</mo><mi>𝐊</mi><mo>×</mo><mi>𝐃</mi><mo>→</mo><mi>𝐖</mi></mrow><annotation encoding="application/x-tex">{}^*\gamma^\mathbf{W}:
\mathbf{X}\times\mathbf{K}\times\mathbf{D} \to \mathbf{W}</annotation></semantics></math>,
but using equations and and substituting, we can derive a function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>γ</mi><mi>𝐖</mi></msup><annotation encoding="application/x-tex">\gamma^\mathbf{W}</annotation></semantics></math>
that gives the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐰</mi><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math>
as a function of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>
alone.</p>
<p>Note in particular that the number of output variables of this direct
module gives the dimension of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐖</mi><annotation encoding="application/x-tex">\mathbf{W}</annotation></semantics></math>
component of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐔</mi><annotation encoding="application/x-tex">\mathbf{U}</annotation></semantics></math>.
We call these variables the <em>direct quantities</em> of the system
(for lack of a better term) since they are the outputs of the direct
module.</p>
</li>
</ul>
<p>Two observations should be made here.</p>
<p>First, in the general case, where multiple direct modules
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ℳ</mi><mn>1</mn></msub><mo>,</mo><msub><mi>ℳ</mi><mn>2</mn></msub><mo>,</mo><mi>…</mi></mrow><annotation encoding="application/x-tex">\mathcal{M}_1, \mathcal{M}_2,
\dots</annotation></semantics></math> are used in the construction of
our system, some of those modules may depend on the outputs of other
direct modules. In this case, each module
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_i</annotation></semantics></math>
corresponds to a function of the form <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>γ</mi><msub><mi>𝐖</mi><mi>i</mi></msub></msup><mo>:</mo><mi>𝐗</mi><mo>×</mo><mi>𝐊</mi><mo>×</mo><mi>𝐃</mi><mo>×</mo><msub><mover><mi>𝐖</mi><mo accent="true">¯</mo></mover><mi>i</mi></msub><mo>→</mo><msub><mi>𝐖</mi><mi>i</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation}
  \gamma^{\mathbf{W}_i}: \mathbf{X}\times\mathbf{K}\times\mathbf{D}\times\mathbf{\overline{W}}_i \to \mathbf{W}_i,
\end{equation}</annotation></semantics></math><!-- (no par break) -->
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐖</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{W}_i</annotation></semantics></math>
is the subspace of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐖</mi><annotation encoding="application/x-tex">\mathbf{W}</annotation></semantics></math>
generated by the variables in the output of module
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝐖</mi><mo accent="true">¯</mo></mover><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{\overline{W}}_i</annotation></semantics></math>
is the subspace of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐖</mi><annotation encoding="application/x-tex">\mathbf{W}</annotation></semantics></math>
generated by those inputs to module
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_i</annotation></semantics></math>
that are not in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>,
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>.
(A direct module’s inputs and outputs are required to be disjoint. Thus
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝐖</mi><mo accent="true">¯</mo></mover><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{\overline{W}}_i</annotation></semantics></math>
is complementary to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐖</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{W}_i</annotation></semantics></math>,
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐖</mi><mi>i</mi></msub><mo>×</mo><msub><mover><mi>𝐖</mi><mo accent="true">¯</mo></mover><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{W}_i \times
\mathbf{\overline{W}}_i</annotation></semantics></math> a subspace of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐖</mi><annotation encoding="application/x-tex">\mathbf{W}</annotation></semantics></math>.)
We will discuss this further in the section on modularization (Section
).</p>
<p>Second, it should be mentioned that the Khalil model allows for the
inclusion of an output function <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐲</mi><mo>=</mo><mi>𝐡</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>𝐱</mi><mo>,</mo><mi>𝐮</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
  \mathbf{y} = \mathbf{h}(t, \mathbf{x}, \mathbf{u}).
\end{equation}</annotation></semantics></math><!-- (no par break) -->
Khalil says that this output vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐲</mi><annotation encoding="application/x-tex">\mathbf{y}</annotation></semantics></math>
“comprises variables of particular interest in the analysis of dynamical
systems .” In the Khalil model, these variables, unlike the variables
that comprise
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐮</mi><annotation encoding="application/x-tex">\mathbf{u}</annotation></semantics></math>,
are not a part of the state equation. They are there for informational
purposes only.</p>
<p>The closest analogue to these variables in BioCro are those variables
that are outputs of the direct module of the system but are not inputs
to the differential module. An example of such variables in the BioCro
library are the <em>kinetic energy</em>, <em>spring energy</em>, and
<em>total energy</em> outputs of the harmonic energy module (class
<code>harmonic_energy</code>). These exist only to give information
about the system using this module since (at least of this writing)
there are no existing modules that use these as inputs.</p>
<ul>
<li>
<p>The <em>differential module</em> corresponds to the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐟</mi><annotation encoding="application/x-tex">\mathbf{f}</annotation></semantics></math>
in equation . This is the Khalil state equation, but with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐮</mi><annotation encoding="application/x-tex">\mathbf{u}</annotation></semantics></math>
divided into components
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐤</mi><annotation encoding="application/x-tex">\mathbf{k}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐝</mi><annotation encoding="application/x-tex">\mathbf{d}</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐰</mi><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math>.
The primary constraint on the differential module is that its output
variables must all be differential quantities (or, equivalently, state
variables), which are determined by the initial values specification as
discussed above.</p>
<p>(BioCro doesn’t require that all state variables be included in the
differential module outputs: if some state variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>i</mi></msub><annotation encoding="application/x-tex">x_i</annotation></semantics></math>
is not, it is assumed that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>x</mi><mo accent="true">̇</mo></mover><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\dot{x}_i = 0</annotation></semantics></math>;
that is, that component of the state remains constant throughout the
life of the system.)</p>
</li>
</ul>
</div>
<div class="section level3">
<h3 id="biocros-concept-of-time">BioCro’s concept of time <a class="anchor" aria-label="anchor" href="#biocros-concept-of-time"></a>
</h3>
<p>In the C++ interface to the BioCro library, there is only one
required user-facing time-related variable—namely, the quantity
<code>timestep</code>, which must be provided as one (and possibly the
only) of the parameters when setting up a system.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;The timestep parameter is different in character from
the other parameters that make up part of the specification of a BioCro
system. It does not correspond to a physical attribute of the real
dynamical system being modeled. Rather, it is an artifact of the way in
which the real system is modeled mathematically. In fact, it should not
be included in the parameters at all and is only there due to a
“historical accident.” Eventually, it is intended that
&lt;code&gt;timestep&lt;/code&gt; will be removed from the BioCro parameters. As
such, we don’t consider it as one of the variables in the set
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;annotation encoding="application/x-tex"&gt;K&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
that we introduced in Section .&lt;/p&gt;'><sup>10</sup></a> (In the R interface,
it is also necessary to provide <code>time</code> as part of the drivers
when setting up or running a system; <code>time</code> can be supplied
implicitly by providing values of <code>doy</code> and
<code>hour</code>.)</p>
<p>The <code>timestep</code> quantity, however, gives rise to an
implicit quantity, the <em>elapsed time</em>, that corresponds well with
the <em>time</em> variable as used in the Khalil and the Giuli-Mazzola
models.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;We shall henceforth refer to the model from &lt;span class="citation"&gt;Giunti and Mazzola (&lt;a href="#ref-Giunti&amp;amp;Mazzola"&gt;2012&lt;/a&gt;)&lt;/span&gt; presented in Section as
simply the &lt;em&gt;Giunti&lt;/em&gt; model: it is essentially the same model
presented fifteen years earlier in &lt;span class="citation"&gt;Giunti (&lt;a href="#ref-Giunti1997-GIUCDS"&gt;1997&lt;/a&gt;)&lt;/span&gt;, but generalized to an
arbitrary monoid, a generalization we have no need to make use of in
BioCro. (This is not entirely true: whereas &lt;span class="citation"&gt;Giunti (&lt;a href="#ref-Giunti1997-GIUCDS"&gt;1997&lt;/a&gt;)&lt;/span&gt; only considers time
systems consisting of the integers, the rationals, the reals, or the
non-negative members of the same, we allow time systems isomorphic to,
but not identical to, the non-negative integers, such as the set of
non-negative even integers. But our time systems will always be
commutative and linearly ordered: we have no need to consider arbitrary
monoids, such as time systems that correspond to cyclic groups,
arbitrary n-dimensional vector spaces, or the quaternions under
multiplication.)&lt;/p&gt;'><sup>11</sup></a> <code>timestep</code>, in fact, denotes
the amount of time that elapses between successive values of any of the
driver variables.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;We could make &lt;em&gt;elapsed time&lt;/em&gt; an explicit
quantity in our systems by writing a differential module with no inputs,
one that always returns the value
&lt;math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;semantics&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;annotation encoding="application/x-tex"&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;
for its one output variable &lt;code&gt;elapsed_time&lt;/code&gt;. Then, assuming we
give it the initial value zero, its value at any time will represent the
amount of time that has elapsed since the start of the simulation, in
whatever time units &lt;code&gt;timestep&lt;/code&gt; is in.&lt;/p&gt;'><sup>12</sup></a></p>
<p><em>Time</em> often shows up explicitly in a BioCro system in the
form of a specific date and time, and what the value of some driver
variable was at that date and time; for example, from the information in
the drivers parameter we may able to make assertions such as <em></em>
But “3 p.m. on April 15, 2005” is not the sort of time with which the
Giunti model deals. Times—<em>durations</em>—in the Giunti model are
members of a monoid, which we can add together to get another time in
the monoid. But we can not add <em></em> and <em></em> in any meaningful
way to get some other date-time. We can, however, add durations: we can,
for example, look at the state of a system one hour after the initial
state of that system, and then look at the state two hours later, and
the second observation will be three hours after the time corresponding
to the system’s initial state (since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">2 + 1 = 3</annotation></semantics></math>).</p>
<p>As hinted above, the <code>timestep</code> quantity generates a
monoid: if the value of <code>timestep</code> is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>,
then the members of that monoid are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>,</mo><mi>δ</mi><mo>,</mo><mi>δ</mi><mo>+</mo><mi>δ</mi><mo>,</mo><mi>δ</mi><mo>+</mo><mi>δ</mi><mo>+</mo><mi>δ</mi><mo>,</mo><mi>δ</mi><mo>+</mo><mi>δ</mi><mo>+</mo><mi>δ</mi><mo>+</mo><mi>δ</mi><mo>,</mo><mi>…</mi></mrow><annotation encoding="application/x-tex">0, \delta, \delta + \delta, \delta + \delta + \delta, \delta + \delta
+ \delta + \delta, \dots</annotation></semantics></math>, ad
infinitum.</p>
<p>Of course, in BioCro, we don’t let our system simulations run
forever, so the set of times dealt with in any given run of a system
doesn’t really quite form a monoid because if we add
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>
to the final time point in our simulation, we get a time that is outside
the domain of our simulation. Conceptually, we can deal with this
problem (of reconciling BioCro’s concept of time with that of the Giunti
model) by imagining that our system simulations <em>could</em> run
forever if we let them (and if we had knowledge infinitely far into the
future of any driver variables we happened to be using); we imagine that
we <em>could</em> do this but that instead, we choose to look at the
behavior of the system only over some finite period of time.</p>
</div>
<div class="section level3">
<h3 id="biocros-concept-of-state">BioCro’s concept of state <a class="anchor" aria-label="anchor" href="#biocros-concept-of-state"></a>
</h3>
<p>In BioCro, at the level of a module, all input quantities are
considered uniformly. There are good reasons for this, reasons that go
beyond mere programmatic convenience. For example, the input to some
module might in one system be determined mechanistically as the output
of some other module; but in a different system, it might come from data
observations and thereby be one of the drivers. But the module using
that input doesn’t care where it comes from.</p>
<p>Once we set up a system, however, each quantity falls neatly into one
of four categories: it is either a parameter, a driver, a differential
quantity, or a direct quantity. (These correspond, respectively, to the
subspaces
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐊</mi><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐖</mi><annotation encoding="application/x-tex">\mathbf{W}</annotation></semantics></math>
discussed in Sections and and to the arguments
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐤</mi><annotation encoding="application/x-tex">\mathbf{k}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐝</mi><annotation encoding="application/x-tex">\mathbf{d}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐰</mi><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math>
in the state equation in the form given in equation .)</p>
<p>The uniform treatment of quantities at the module level is reflected
in the C++ code used to implement BioCro simulations: each quantity used
in a given system is incorporated into a C++ structure of a user-defined
type called <code>state_map</code>, which maps names of quantities to
the value such quantities have at some particular time. This naturally
leads to referring to the aggregate of the values of all quantities of
the system at some particular point in time as the <em>state</em> of the
system at that time. Thus, while Khalil’s model distinguishes betwee the
state and the inputs, the term state as used in BioCro refers to the
parameters, drivers, differential quantities, and direct quantities as a
whole (equivalent to Khalil’s state <em>and</em> drivers).</p>
<p>This section attempts to reconcile this conception of state with that
commonly used in dynamical systems theory, and in particular, with the
formulations presented in chapter . Elsewhere in this document, we use
the term <em>state</em> exclusively in reference to its usual definition
as employed in the Khalil, Giuli-Mazzola, and Barreira-Valls models.
When discussing BioCro, we refer to the state variables as the
<em>differential quantities</em> to avoid misrepresenting BioCro’s idea
of state. In this section, however, we must necessarily use
<em>state</em> to refer to both conceptions, and we will try to clarify
which definition is meant whenever it is unclear from context.</p>
<div class="section level4">
<h4 id="biocro-state-and-the-khalil-model">BioCro state and the Khalil model<a class="anchor" aria-label="anchor" href="#biocro-state-and-the-khalil-model"></a>
</h4>
<p>Khalil remarks that the state variables “represent the memory that
the dynamical system has of its past.” As Laplace <span class="citation">(<a href="#ref-alma99954908866305899">Dale
1995</a>)</span> remarks, “We ought then to consider the present state
of the universe as the effect of its previous state and as the cause of
that which is to follow.” The inputs in the model, on the other hand,
are in general completely arbitrary. They are not determined by the
state or by their own past or future values. They help determine, but
are not determined by, the evolution of the state of the system. In a
sense, they are like the hand of the experimenter-god touching and
influencing this otherwise mechanistically-determined system.</p>
<p>In BioCro, the inputs are considered part of the state, partly as a
matter of convenience; but, convenience aside, there is also a
philosophical justification for this: In many systems, the inputs may
clearly be thought of as somehow external to the system. When studying
an electrical circuit, for example, the experimenter may apply
electrical inputs to the system and see how the system responds. Even in
a controlled plant-growth experiment conducted in a climate-controlled
greenhouse, the environmental inputs may be applied somewhat
arbitrarily. In BioCro, by contrast, the inputs (the <em>drivers</em>)
are usually related to weather and other aspects of the
environment—temperature, humidity, radiation, and so on. Unlike in a
controlled experiment, these environmental variables evolve according to
their own laws; they are not under the control of the experimenter. In a
truly comprehensive model, their laws of evolution would be included
right alongside the laws determining plant growth. But generally, to do
so would overly complicate the model, and by and large, given the
inherently chaotic nature of meteorological processes and the vast
amounts of additional data that would be required, it is not at all
feasible to do so. So in BioCro, we regard them as a part of the
system—as part of the <em>state</em> of the system—but as a part that is
taken as given rather than as a part that is to be derived from some
general rules governing the evolution of natural systems.</p>
<p>None of this is to say, of course, that BioCro can’t also be used to
model controlled experiments, such as those carried out in a greenhouse;
or to model “thought experiments” or “what if” scenarios: <em>What would
happen if we used the weather data from 2005 but assumed a much higher
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">CO</mtext><mtext mathvariant="normal">2</mtext></msub><annotation encoding="application/x-tex">\text{CO}_\text{2}</annotation></semantics></math>
concentration?</em></p>
</div>
<div class="section level4">
<h4 id="biocro-state-and-the-giunti-model">BioCro state and the Giunti model<a class="anchor" aria-label="anchor" href="#biocro-state-and-the-giunti-model"></a>
</h4>
<p>Giunti and Mazzola’s model definition was cited in the supplementary
materials to <span class="citation">Lochocki et al. (<a href="#ref-10.1093/insilicoplants/diac003">2022</a>)</span> as
justification for considering all quantities involved in a system
(except for time) as part of the state. Whatever the merits of that
argument, in retrospect, this possibly amounts to a sort of
cherry-picking of the Giunti-Mazzola definition because it is not
altogether clear whether BioCro dynamical systems, as envisioned in that
paper, have, in general, a collection of well-defined transition
functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>g</mi><mi>t</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>t</mi><mo>∈</mo><mi>T</mi></mrow></msub><annotation encoding="application/x-tex">(g^t)_{t
\in T}</annotation></semantics></math>. Whether they do or do not turns
on the question of how we interpret the stipulation, given in the
supplement, that “the term state is used to refer to all quantities
involved in the system, except time.”</p>
<p>As we demonstrate here, a BioCro system having drivers but that does
not include a time-like variable amongst those drivers does not, in
general, conform to the Giunti model.</p>
<p>To see this, let us consider a typical BioCro system in which the
driver component consists of the values of a number of weather-related
variables over the course of a year, and suppose these variables happen
to all have the same values at two different times; for example, suppose
the weather at 1 p.m. on April 12, 2008 is exactly the same as the
weather at 3 p.m. on May 16, 2008 to the extent <em>weather</em> is
captured by the attributes in our model. Moreover, suppose our system
has what might be a typical array of differential variables—namely,
those that describe the state of growth of a plant that is subjected to
the environment described by the driver variables in the system.</p>
<p>Consider now two identical states—one,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mn>1</mn></msub><annotation encoding="application/x-tex">s_1</annotation></semantics></math>,
corresponding to a seedling planted at 1 p.m. on April 12, 2008, and
one,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mn>2</mn></msub><annotation encoding="application/x-tex">s_2</annotation></semantics></math>,
corresponding to an identical seedling planted at 3 p.m. on May 16,
2008. The states are identical because the attributes of the seedlings,
described by the differential variables, are identical, and the
attributes of the weather, described by the driver variables, are also
identical; and because the parameters (being constant) are identical,
and the values of the “direct” variables, being functions of the other
three components, are also identical. (Recall that we are specifically
excluding date and time from our notion of state here.) In other words,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><mo>=</mo><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_1 = s_2</annotation></semantics></math>.</p>
<p>Now consider one of the transition functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>g</mi><mi>t</mi></msup><annotation encoding="application/x-tex">g^t</annotation></semantics></math>—say,
for example, some function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>g</mi><mi>u</mi></msup><annotation encoding="application/x-tex">g^u</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math>
corresponds to a duration of 30 days. Then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>u</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">g^u(s_1)</annotation></semantics></math>
will be the state corresponding the the attributes of the seedling
planted on April 12 and its environment one month later, on May 12,
2008. And
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>u</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">g^u(s_2)</annotation></semantics></math>
will be the state corresponding the the attributes of the seedling
planted on May 16 and its environment approximately one month later, on
June 15. Will the weather at 1 p.m. on May 12, 2008 be identical to that
at 3 p.m. on June 15, 2008? According to the Giunti model, it should be,
since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><mo>=</mo><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_1 = s_2</annotation></semantics></math>
implies that state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>u</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">g^u(s_1)</annotation></semantics></math>
equals state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>u</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">g^u(s_2)</annotation></semantics></math>;
and if two states are equal, those components of the state that describe
the weather should be equal as well.</p>
<p>But we know that something is wrong here, because even if the same
weather occurs at two different times, we can’t expect the weather
patterns going forward to develop in the same way. Moreover, in all
likelyhood the identical seedlings planted on April 12 and May 16 will
no longer be identical 30 days later because they likely will have been
subjected to different weather conditions.</p>
<p>There are two ways (at least) out of this predicament. One is to
ensure that the driver component of the state never repeats itself. Any
monotonically-increasing driver variable would do the trick, but the
most natural way of ensuring no repetitions is probably to include some
representation of the time, such as the calendar date and time, Julian
date, reduced Julian date, or Unix time as part of the driver component
of the state. (The R interface to BioCro in fact requires either both
the day-of-year and hour of the day as driver variables or it requires a
monotonically-increasing variable called <em>time</em>. The C++
interface, however, requires neither of these.)</p>
<p>A second way, one that makes the system formally time-independent, is
to modify the driver component in our notion of the state. In this
scheme, the driver component of a state is not just an array of values
the driver variables happen to have at some particular time. Now,
instead, it is an encapsulation of the future of the driver variable
values indefinitely far into the future. One way to imagine this, if we
are thinking of the drivers as corresponding to the weather, is to think
of the driver component of the state at some particular time as a
weather prediction giving the weather at that time <em>and for every
future time</em>, i.e., the weather one day from now, two days from now,
and so on; moreover, not just any prediction, but a 100% accurate one.
The state now, without having to include the date or time, encapsulates
all the information we need to have in order to know what the state will
be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
amount of time in the future.</p>
<p>We bring this up to show that even in the presence of drivers
(<em>inputs</em>, in Khalil’s terminology), the notion of an autonomous
system is possible. And we can have systems that conform to the Giunti
model without requiring that states on different dates be distinct. For
example, imagine a greenhouse experiment in which the climate conditions
in the greenhouse repeat exactly the same pattern from one day to the
next. In this system, the driver state at noon—the “weather” prediction
for each moment going forward (one hour later, 10 hours later, 10 days
later)—will be exactly the same from one day to the next. And so too
will the evolution of a generic seedling: the evolution of a seedling
planted at noon on one day will be the same as the evolution of an
identical seedling planted at noon twenty days later.</p>
<p>In practical terms, however, this is a rather complicated model. The
state space will no longer be a Euclidean space, since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>,
the driver component of the state space, will no longer be the Euclidean
space
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>r</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^r</annotation></semantics></math>
but will instead be the set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐑</mi><mi>r</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><annotation encoding="application/x-tex">(\mathbf{R}^r)^T</annotation></semantics></math>
of all functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>γ</mi><mi>𝐃</mi></msup><mo>:</mo><mi>T</mi><mo>→</mo><msup><mi>𝐑</mi><mi>r</mi></msup></mrow><annotation encoding="application/x-tex">\gamma^\mathbf{D}: T \to \mathbf{R}^r</annotation></semantics></math>.
(Note that the state transition of duration
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math>
restricted to the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>
component of the state is at least easily defined: if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>γ</mi><annotation encoding="application/x-tex">\gamma</annotation></semantics></math>
is the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>
component of some state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐬</mi><annotation encoding="application/x-tex">\mathbf{s}</annotation></semantics></math>,
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>u</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>γ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">g^u(\gamma)</annotation></semantics></math>
will be the function defined by the rule
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>↦</mo><mi>γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo>+</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">t \mapsto \gamma(u + t)</annotation></semantics></math>.)</p>
<p>The upshot is that the Giunti model does not naturally describe a
BioCro system having drivers unless some proxy for time is allowed to be
a component of those drivers. It should also be noted that BioCro does
not make use of two important generalizations in the Giunti model: in
BioCro, the state space always <em>will</em> be a subset (in fact, a
<em>connected</em> subset) of a Euclidean space, and state transitions
(using <em>state</em> in Khalil’s sense) will always be differential
equation based. Thus, we find that Khalil’s model provides a better
description of BioCro systems.</p>
</div>
<div class="section level4">
<h4 id="the-state-space-as-a-manifold">The state space as a manifold <a class="anchor" aria-label="anchor" href="#the-state-space-as-a-manifold"></a>
</h4>
<p>One of the arguments given in the supplementary materials to <span class="citation">Lochocki et al. (<a href="#ref-10.1093/insilicoplants/diac003">2022</a>)</span> for
considering <em>all</em> variables as state variables is that “the
division between state and auxiliary variables is arbitrary.” Whether or
not this is a compelling argument for considering “all quantities
equal”, this statement is, at least on a formal level, largely true, at
least in the case where variables mutually determine one another. As
stated at the conclusion of Appendix II in <span class="citation">Mesarović and Takahara (<a href="#ref-alma99267312205899">1975</a>)</span>,</p>
<blockquote>
<p>The starting point for any modeling is the observations and the
assumption about the existence of relationships between them. The
primary concept of a system ought to be definable just with that much
data. Whether such a relationship can be described as a transition in a
state space is a point that needs to be proven. Even if this is
possible, <em>a state space is not unique, which indicates the secondary
nature of the concept of state</em> [emphasis mine].</p>
</blockquote>
<p>Here, the authors are presumably using <em>state</em> in the less
comprehensive sense, where it is distinguished from system inputs and
outputs, though conceivably they could simply mean that which attributes
we choose to observe and codify into a notion of <em>state</em> is not
unique; but for the sake of argument, we’ll assume they mean at least
the former.</p>
<p>(But the authors, in fact, hint at an altogether different view of
what is meant by the state of a system. In this view, everything that
can be observed about a system is encompassed by the system’s inputs and
outputs: the system is essentially a black box, and how it responds to
given inputs at any particular time is not always the same. This is
because some unobservable aspects of the system come into play. These
unobservables constitute the <em>state</em> of the system, and how it
responds at any given time to given inputs depends on what
<em>state</em> it happens to be in. A helpful analogy here might be the
notion of a person’s <em>state of mind</em> as a determinant of how they
might react to a particular event.)</p>
<p>However expansive we choose to make our notion of <em>state</em>, one
thing is clear: if we choose to regard the parameters, drivers, and the
relationship between quantities embodied in the direct modules as
constraints on the state space of our systems, then <em>given</em> that
a state lies in this state space, we can fully specify the state using
only the values of the so-called <em>differential</em> variables (plus
time); the values of all of the other quantities can be determined from
these. Thus, if the total number of quantites in the system (including
time) is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,
and the number of differential variables is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>,
then the state space may be viewed as a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math>-dimensional
manifold embedded in Euclidean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-space
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>n</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^n</annotation></semantics></math>.
Put another way, no matter how many variables we use to describe the
state of the system, there are still only
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math>
degrees of freedom: the parameters can only take one value, the time
variable determines the values of all the driver variables, and the
values of these together with the values of the differential variables
determine the values of the remaining variables, the direct
variables.</p>
<p>An analogy may help make this clearer: Say we wish to consider all
points on earth. If we don’t limit ourselves to points on the surface,
then we could specify such points with three coordinates—longitude,
latitude, and altitude. Large values of <em>altitude</em> will
correspond to points above the earth’s surface, and negative values will
usually correspond to points in the earth’s interior. We are considering
arbitrary points in a three-dimensional space, and so it makes sense
that we need all three coordinates to fully specify such a point.</p>
<p>But suppose we now say that we only want to consider points on the
earth’s surface. Given this constraint, this understanding that we are
only going to try to describe points on the surface of the earth, we can
get by with only two coordinates: we need only specify the longitude and
the latitude. We <em>could</em> include the third number, the altitude,
as well (provided we know it), but it is now not necessary, because it
is understood that the point lies on the earth’s surface. If we consider
a system whose <em>state</em> comprises the location of some given
object on the surface of the earth, then the state space <em>is</em>
that surface, a two-dimensional space embedded in Euclidean 3-space.</p>
<p>Note that in this example, it matters which two coordinates we choose
for describing states. Generally, it will not, for example, suffice to
know only the altitude and the longitude, since, given some choice of
altitude and longitude, there may be many points of various latitudes
that match. (There are exceptional cases, of course: if we specify the
altitude as 8848.86 (meters), even without having specified a longitude
or latitude (let alone both), we know the object is at the top of Mount
Everest.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;Here, we are using &lt;em&gt;altitude&lt;/em&gt; to mean “height
above sea level”, or what is, for points on the earth’s surface, usually
called &lt;em&gt;elevation&lt;/em&gt;.&lt;/p&gt;"><sup>13</sup></a>)</p>
</div>
</div>
<div class="section level3">
<h3 id="modularization-in-biocro">Modularization in BioCro <a class="anchor" aria-label="anchor" href="#modularization-in-biocro"></a>
</h3>
<p>As mentioned in Section , any BioCro system can be replaced by an
equivalent system using only a single module of each type. We merely
have to write one direct module and one differential module, where each
(respectively) combines the effects of all the individual direct and
differential modules that were used in the original system.</p>
<p>We use “merely” advisedly here, because one of the main strengths of
BioCro is the ability to modularize, so that once we have a wide
repertoire of modules to choose from, we can choose and combine them in
whatever way is useful, without having to write a new module each time
we want to tweak some aspect of the system as a whole.</p>
<p>In this section, we look at this combining of modules on a formal
level, delineating the requirements for using two or more modules in
place of one and the effects of doing so. We start with the differential
module case since it is the simpler of the two.</p>
<div class="section level4">
<h4 id="modularization-of-the-derivative-function">Modularization of the derivative function<a class="anchor" aria-label="anchor" href="#modularization-of-the-derivative-function"></a>
</h4>
<p>As mentioned in Section , when a BioCro system uses only a single
differential module, that module corresponds to the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐟</mi><annotation encoding="application/x-tex">\mathbf{f}</annotation></semantics></math>
in Khalil state equation . We shall henceforth refer to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐟</mi><annotation encoding="application/x-tex">\mathbf{f}</annotation></semantics></math>
as the <em>derivative</em> function for the system.</p>
<p>As it turns out, in BioCro, the derivative function never depends on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
directly; if there is any temporal dependence in function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐟</mi><annotation encoding="application/x-tex">\mathbf{f}</annotation></semantics></math>,
it is always via some driver variable or differential variable. (Recall
that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
represents the elapsed time in a BioCro system; although some
calculations may depend on the time of year or the time of day, they do
not depend on the elapsed time.) Therefore, we can rewrite equation as
<!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝐱</mi><mo accent="true">̇</mo></mover><mo>=</mo><mi>𝐟</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo>,</mo><mi>𝐤</mi><mo>,</mo><mi>𝐝</mi><mo>,</mo><mi>𝐰</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
  \dot{\mathbf{x}} = \mathbf{f}(\mathbf{x}, \mathbf{k}, \mathbf{d}, \mathbf{w}).
\end{equation}</annotation></semantics></math><!-- (no par break) -->
Thus,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐟</mi><mo>:</mo><mi>𝐗</mi><mo>×</mo><mi>𝐊</mi><mo>×</mo><mi>𝐃</mi><mo>×</mo><mi>𝐖</mi><mo>→</mo><mi>𝐗</mi></mrow><annotation encoding="application/x-tex">\mathbf{f}: \mathbf{X}\times\mathbf{K}\times\mathbf{D}\times\mathbf{W}\to\mathbf{X}</annotation></semantics></math>.
From here on out, we shall adopt BioCro’s notion of state space and
denote it as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐒</mi><annotation encoding="application/x-tex">\mathbf{S}</annotation></semantics></math>,
so that <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mo>=</mo><mi>𝐗</mi><mo>×</mo><mi>𝐊</mi><mo>×</mo><mi>𝐃</mi><mo>×</mo><mi>𝐖</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
    \mathbf{S} = \mathbf{X}\times\mathbf{K}\times\mathbf{D}\times\mathbf{W}.
\end{equation*}</annotation></semantics></math><!-- (no par break) --><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐟</mi><annotation encoding="application/x-tex">\mathbf{f}</annotation></semantics></math>
is then a function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐟</mi><mo>:</mo><mi>𝐒</mi><mo>→</mo><mi>𝐗</mi></mrow><annotation encoding="application/x-tex">\mathbf{f}: \mathbf{S} \to \mathbf{X}</annotation></semantics></math>,
and the state equation, which we shall now refer to as the
<em>derivative</em> equation, is just <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝐱</mi><mo accent="true">̇</mo></mover><mo>=</mo><mi>𝐟</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐬</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation}
  \dot{\mathbf{x}} = \mathbf{f}(\mathbf{s}),
\end{equation}</annotation></semantics></math><!-- (no par break) -->
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐬</mi><annotation encoding="application/x-tex">\mathbf{s}</annotation></semantics></math>
denotes a state in the state space
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐒</mi><annotation encoding="application/x-tex">\mathbf{S}</annotation></semantics></math>.</p>
<p>In general, we can write any state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐬</mi><annotation encoding="application/x-tex">\mathbf{s}</annotation></semantics></math>
in terms of the coordinate variables describing each of the component
spaces; that is, <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐬</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>k</mi><mn>0</mn></msub><mo>,</mo><msub><mi>k</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>k</mi><mrow><mi>q</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>d</mi><mn>0</mn></msub><mo>,</mo><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>d</mi><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>w</mi><mn>0</mn></msub><mo>,</mo><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>w</mi><mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{equation*}
    \mathbf{s} = (x_0, x_1, \dots, x_{n-1}, k_0, k_1, \dots,
               k_{q-1}, d_0, d_1, \dots, d_{r-1}, w_0, w_1, \dots, w_{s-1})
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
are the dimensions of the component spaces
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐊</mi><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐖</mi><annotation encoding="application/x-tex">\mathbf{W}</annotation></semantics></math>,
respectively.</p>
<p>Before we talk about decomposing the derivative function of a system,
we will first describe what we mean by a valid differential module for a
BioCro system.</p>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">X = \{x_0, x_1, \dots, x_{n-1}\}</annotation></semantics></math>
be the set of differential variables of the system, and let
<!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>k</mi><mn>0</mn></msub><mo>,</mo><msub><mi>k</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>k</mi><mrow><mi>q</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>d</mi><mn>0</mn></msub><mo>,</mo><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>d</mi><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>w</mi><mn>0</mn></msub><mo>,</mo><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>w</mi><mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\begin{equation*}
    S = \{x_0, x_1, \dots, x_{n-1}, k_0, k_1, \dots, k_{q-1},
          d_0, d_1, \dots, d_{r-1}, w_0, w_1, \dots, w_{s-1}\}
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
be the set of <em>all</em> the coordinate variables needed to specify a
state in the state space of the system. Then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℳ</mi><annotation encoding="application/x-tex">\mathcal{M}</annotation></semantics></math>
is a valid differential module for the system if the input variables are
contained in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
and the output variables are contained in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>.</p>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐌</mi><mtext mathvariant="normal">in</mtext></msub><annotation encoding="application/x-tex">\mathbf{M}_\text{in}</annotation></semantics></math>
be the vector subspace of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐒</mi><annotation encoding="application/x-tex">\mathbf{S}</annotation></semantics></math>
generated by the input variables of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℳ</mi><annotation encoding="application/x-tex">\mathcal{M}</annotation></semantics></math>
and let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐌</mi><mtext mathvariant="normal">out</mtext></msub><annotation encoding="application/x-tex">\mathbf{M}_\text{out}</annotation></semantics></math>
be the vector subspace of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math>
generated by the output variables of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℳ</mi><annotation encoding="application/x-tex">\mathcal{M}</annotation></semantics></math>.
Then the <em>derivative function</em> for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℳ</mi><annotation encoding="application/x-tex">\mathcal{M}</annotation></semantics></math>
is some function <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>𝐟</mi><mo accent="true">̂</mo></mover><mi>𝐌</mi></msub><mo>:</mo><msub><mi>𝐌</mi><mtext mathvariant="normal">in</mtext></msub><mo>→</mo><msub><mi>𝐌</mi><mtext mathvariant="normal">out</mtext></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
    \hat{\mathbf{f}}_\mathbf{M}: \mathbf{M}_\text{in} \to \mathbf{M}_\text{out}.
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
To each such function, we may associate a unique function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐟</mi><mi>𝐌</mi></msub><mo>:</mo><mi>𝐒</mi><mo>→</mo><mi>𝐗</mi></mrow><annotation encoding="application/x-tex">\mathbf{f}_\mathbf{M}: \mathbf{S} \to \mathbf{X}</annotation></semantics></math>
as follows:</p>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛑</mi><annotation encoding="application/x-tex">\pmb{\pi}</annotation></semantics></math>
be the projection of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐒</mi><annotation encoding="application/x-tex">\mathbf{S}</annotation></semantics></math>
onto
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐌</mi><mtext mathvariant="normal">in</mtext></msub><annotation encoding="application/x-tex">\mathbf{M}_\text{in}</annotation></semantics></math>,
and let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛊</mi><annotation encoding="application/x-tex">\pmb{\iota}</annotation></semantics></math>
be the injective function of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐌</mi><mtext mathvariant="normal">out</mtext></msub><annotation encoding="application/x-tex">\mathbf{M}_\text{out}</annotation></semantics></math>
into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math>
that assigns each coordinate in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
that is not an output variable of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℳ</mi><annotation encoding="application/x-tex">\mathcal{M}</annotation></semantics></math>
the value zero. Then we define <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐟</mi><mi>𝐌</mi></msub><mo>=</mo><mi>𝛊</mi><mo>∘</mo><msub><mover><mi>𝐟</mi><mo accent="true">̂</mo></mover><mi>𝐌</mi></msub><mo>∘</mo><mi>𝛑</mi><mo>:</mo><mi>𝐒</mi><mover><mo>→</mo><mi>𝛑</mi></mover><msub><mi>𝐌</mi><mtext mathvariant="normal">in</mtext></msub><mover><mo>→</mo><msub><mover><mi>𝐟</mi><mo accent="true">̂</mo></mover><mi>𝐌</mi></msub></mover><msub><mi>𝐌</mi><mtext mathvariant="normal">out</mtext></msub><mover><mo>→</mo><mi>𝛊</mi></mover><mi>𝐗</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
    \mathbf{f}_\mathbf{M} = \pmb{\iota} \circ \hat{\mathbf{f}}_\mathbf{M} \circ \pmb{\pi}:
        \mathbf{S} \stackrel{\pmb{\pi}}{\to} \mathbf{M}_\text{in}
               \stackrel{\hat{\mathbf{f}}_\mathbf{M}}{\longrightarrow} \mathbf{M}_\text{out}
               \stackrel{\pmb{\iota}}{\to} \mathbf{X}.
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
We shall call the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐟</mi><mi>𝐌</mi></msub><annotation encoding="application/x-tex">\mathbf{f}_\mathbf{M}</annotation></semantics></math>
the <em>system-complete derivative function for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℳ</mi><annotation encoding="application/x-tex">\mathcal{M}</annotation></semantics></math></em>.</p>
<p>Now suppose we have a collection
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>ℳ</mi><mn>1</mn></msub><mo>,</mo><msub><mi>ℳ</mi><mn>2</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>ℳ</mi><mi>m</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{\mathcal{M}_1, \mathcal{M}_2, \dots, \mathcal{M}_m\}</annotation></semantics></math>
of differential modules assumed to be consistent with (the rest of) our
system, and let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>𝐟</mi><msub><mi>𝐌</mi><mn>𝟏</mn></msub></msub><mo>,</mo><msub><mi>𝐟</mi><msub><mi>𝐌</mi><mn>𝟏</mn></msub></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>𝐟</mi><msub><mi>𝐌</mi><mi>𝐦</mi></msub></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{\mathbf{f}_\mathbf{M_1}, \mathbf{f}_\mathbf{M_1}, \dots,
\mathbf{f}_\mathbf{M_m}\}</annotation></semantics></math> be their
corresponding system-complete derivative functions. Then the
<em>combined derivative function</em> for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>ℳ</mi><mn>1</mn></msub><mo>,</mo><msub><mi>ℳ</mi><mn>2</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>ℳ</mi><mi>m</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{\mathcal{M}_1, \mathcal{M}_2,
\dots, \mathcal{M}_m\}</annotation></semantics></math> is the function
<!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐟</mi><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>m</mi><mo stretchy="false" form="postfix">}</mo></mrow></munder><msub><mi>𝐟</mi><msub><mi>𝐌</mi><mi>𝐢</mi></msub></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation*}
    \mathbf{f} = \sum_{i\in \{1, 2, \dots, m\}} \mathbf{f}_\mathbf{M_i},
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
defined by the rule</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐬</mi><mo>↦</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>m</mi><mo stretchy="false" form="postfix">}</mo></mrow></munder><msub><mi>𝐟</mi><msub><mi>𝐌</mi><mi>𝐢</mi></msub></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐬</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
    \mathbf{s} \mapsto \sum_{i\in \{1, 2, \dots, m\}} \mathbf{f}_\mathbf{M_i}(\mathbf{s}).
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>ℳ</mi><mn>1</mn></msub><mo>,</mo><msub><mi>ℳ</mi><mn>2</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>ℳ</mi><mi>m</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{\mathcal{M}_1, \mathcal{M}_2, \dots, \mathcal{M}_m\}</annotation></semantics></math>
comprise the differential modules for a system, then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐟</mi><annotation encoding="application/x-tex">\mathbf{f}</annotation></semantics></math>
is that system’s derivative function.</p>
<p>In other words, the outputs from each individual differential module
are treated as terms that must be added together to form the full
derivative. For each module, the system-complete derivative function as
defined above calculates the values of some elements of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>,
setting the rest to 0. Then, the output from each system-complete
derivative function can be added together to form the full derivative.
This is the operation performed by the combined derivative function.</p>
<p>We could always write a single differential module
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℳ</mi><annotation encoding="application/x-tex">\mathcal{M}</annotation></semantics></math>
that has
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐟</mi><annotation encoding="application/x-tex">\mathbf{f}</annotation></semantics></math>
as its system-complete derivative function and then use it in place of
the collection of modules
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>ℳ</mi><mn>1</mn></msub><mo>,</mo><msub><mi>ℳ</mi><mn>2</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>ℳ</mi><mi>m</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{\mathcal{M}_1, \mathcal{M}_2, \dots, \mathcal{M}_m\}</annotation></semantics></math>
in any system that uses them. But this module will likely combine
several mechanistic bio-systems concepts, and one of the strengths of
BioCro is the ability to tweak one mechanistic model without having to
rewrite multiple modules that might use it.</p>
</div>
<div class="section level4">
<h4 id="decomposing-the-direct-module-function">Decomposing the direct module function<a class="anchor" aria-label="anchor" href="#decomposing-the-direct-module-function"></a>
</h4>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒮</mi><annotation encoding="application/x-tex">\mathcal{S}</annotation></semantics></math>
be a BioCro system, and let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mo>=</mo><mi>𝐗</mi><mo>×</mo><mi>𝐊</mi><mo>×</mo><mi>𝐃</mi><mo>×</mo><mi>𝐖</mi></mrow><annotation encoding="application/x-tex">\mathbf{S} =
\mathbf{X}\times\mathbf{K}\times\mathbf{D} \times \mathbf{W}</annotation></semantics></math>
be the state space of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒮</mi><annotation encoding="application/x-tex">\mathcal{S}</annotation></semantics></math>.
As mentioned in Section , the direct module component of a BioCro system
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒮</mi><annotation encoding="application/x-tex">\mathcal{S}</annotation></semantics></math>
corresponds to a function <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>γ</mi><mi>𝐖</mi></msup><mo>:</mo><mi>𝐗</mi><mo>×</mo><mi>𝐊</mi><mo>×</mo><mi>𝐃</mi><mo>→</mo><mi>𝐖</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
    \gamma^\mathbf{W}: \mathbf{X}\times\mathbf{K}\times\mathbf{D} \to \mathbf{W} \label{eq:dir_mod_component_fn}
\end{equation}</annotation></semantics></math><!-- (no par break) -->
that determines the value of the “direct variable” component of a state
from the value of the other components. For convenience in what follows,
we shall write
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐇</mi><annotation encoding="application/x-tex">\mathbf{H}</annotation></semantics></math>
to abbreviate the cross product
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐗</mi><mo>×</mo><mi>𝐊</mi><mo>×</mo><mi>𝐃</mi></mrow><annotation encoding="application/x-tex">\mathbf{X}\times\mathbf{K}\times\mathbf{D}</annotation></semantics></math>.
Thus we may write as <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>γ</mi><mi>𝐖</mi></msup><mo>:</mo><mi>𝐇</mi><mo>→</mo><mi>𝐖</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
    \gamma^\mathbf{W}: \mathbf{H} \to \mathbf{W}.
\end{equation*}</annotation></semantics></math></p>
<p>In general, however, the direct module component of a system will be
subdivided into two or more submodules. In this section, we will show
that the <em>ordered sum</em> of two modules (a notion defined below) is
itself a module; this is the key to understanding how to modularize the
direct module function.</p>
<p>As mentioned in Section , when a system has more than one direct
module, each constituent module
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_i</annotation></semantics></math>
corresponds to a function <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>γ</mi><msub><mi>𝐖</mi><mi>i</mi></msub></msup><mo>:</mo><mi>𝐗</mi><mo>×</mo><mi>𝐊</mi><mo>×</mo><mi>𝐃</mi><mo>×</mo><msub><mover><mi>𝐖</mi><mo accent="true">¯</mo></mover><mi>i</mi></msub><mo>→</mo><msub><mi>𝐖</mi><mi>i</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation}
  \gamma^{\mathbf{W}_i}: \mathbf{X}\times\mathbf{K}\times\mathbf{D}\times\mathbf{\overline{W}}_i \to \mathbf{W}_i,
\end{equation}</annotation></semantics></math><!-- (no par break) -->
or, using the abbreviation used above, <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>γ</mi><msub><mi>𝐖</mi><mi>i</mi></msub></msup><mo>:</mo><mi>𝐇</mi><mo>×</mo><msub><mover><mi>𝐖</mi><mo accent="true">¯</mo></mover><mi>i</mi></msub><mo>→</mo><msub><mi>𝐖</mi><mi>i</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
  \gamma^{\mathbf{W}_i}: \mathbf{H}\times\mathbf{\overline{W}}_i \to \mathbf{W}_i. \label{eq:dir_mod_fn}
\end{equation}</annotation></semantics></math></p>
<p>Letting
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
denote the set of variables corresponding to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐇</mi><annotation encoding="application/x-tex">\mathbf{H}</annotation></semantics></math>
and denoting the input and output variables of module
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_i</annotation></semantics></math>
as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐈𝐧</mo><msub><mi>ℳ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{In}}\mathcal{M}_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{Out}}\mathcal{M}_i</annotation></semantics></math>
respectively, we can write <!-- (no par break) --> <span class="math display">$$\begin{align*}
    \mathbf{W}_i &amp;=
\mathbf{R}^{\operatorname{\mathbf{Out}}\mathcal{M}_i} \\
    \intertext{and}
    \mathbf{\overline{W}}_i &amp;=
\mathbf{R}^{\operatorname{\mathbf{In}}\mathcal{M}_i\smallsetminus H},
\end{align*}$$</span> <!-- (no par break) --> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐈𝐧</mo><msub><mi>ℳ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{In}}\mathcal{M}_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{Out}}\mathcal{M}_i</annotation></semantics></math>
are disjoint, since direct modules never share inputs and outputs.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;When we say that direct modules never share inputs and
outputs, we are specifically referring to direct modules used in the
construction of a dynamical system, that is, direct modules that are
members of the &lt;em&gt;set of direct modules&lt;/em&gt; mentioned at the outset in
our discussion of the BioCro model. But there do, in fact, exist
modules, also going by the name &lt;em&gt;direct module&lt;/em&gt;, that &lt;em&gt;do&lt;/em&gt;
have one or more input and output variables in common. We won’t consider
such modules here, and it what follows, we always consider only direct
modules of the former type, where the input and output sets are
disjoint.&lt;/p&gt;"><sup>14</sup></a> Note
that it may be the case that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐈𝐧</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>⊆</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{In}}\mathcal{M}_i\subseteq H</annotation></semantics></math>;
in this case
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝐖</mi><mo accent="true">¯</mo></mover><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{\overline{W}}_i</annotation></semantics></math>
is 0-dimensional and reduces to <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>γ</mi><msub><mi>𝐖</mi><mi>i</mi></msub></msup><mo>:</mo><mi>𝐇</mi><mo>→</mo><msub><mi>𝐖</mi><mi>i</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
    \gamma^{\mathbf{W}_i}: \mathbf{H} \to \mathbf{W}_i.
\end{equation*}</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
corresponds to the union of all the differential variables, parameters,
and driver variables of the system. Usually, it will be the case that
any given direct module in a system will not use all of the variables in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>:
not all of the variables in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
will affect the value of the output, nor will they even be listed in the
list returned by the module’s <code>get_inputs()</code> function. But
they are all always <em>potentially</em> available for use by any direct
module, and in what follows, it will be convenient to assume that the
direct module inputs include all the variables of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>;
that is,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐈𝐧</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>⊇</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{In}}\mathcal{M}_i\supseteq H</annotation></semantics></math>,
for all direct modules
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_i</annotation></semantics></math>.
This way, the only thing that changes about the domain of the module
function between various direct modules is the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝐖</mi><mo accent="true">¯</mo></mover><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{\overline{W}}_i</annotation></semantics></math>
component of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐇</mi><mo>×</mo><msub><mover><mi>𝐖</mi><mo accent="true">¯</mo></mover><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{H}\times\mathbf{\overline{W}}_i</annotation></semantics></math>.
This will simplify the exposition of what follows.</p>
<p>(To take a simple example of formal dependence versus actual
dependence, consider a two-variable function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math>
defined by the rule
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>↦</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(x,y)\mapsto x^2</annotation></semantics></math>.
Formally, this is a function of two variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>.
But the value of the function never actually depends on the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>.)</p>
<div class="section level5">
<h5 class="unnumbered" id="the-ordered-sum-of-two-direct-modules">The ordered sum of two direct modules<a class="anchor" aria-label="anchor" href="#the-ordered-sum-of-two-direct-modules"></a>
</h5>
<p>Suppose that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_j</annotation></semantics></math>
are two direct modules having disjoint sets of output variables (that
is,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>∩</mo><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>j</mi></msub><mo>=</mo><mi>∅</mi></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{Out}}\mathcal{M}_i\cap\operatorname{\mathbf{Out}}\mathcal{M}_j=\emptyset</annotation></semantics></math>),
and suppose also that none of the outputs of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_j</annotation></semantics></math>
are inputs for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_i</annotation></semantics></math>;
that is,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐈𝐧</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>∩</mo><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>j</mi></msub><mo>=</mo><mi>∅</mi></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{In}}\mathcal{M}_i\cap\operatorname{\mathbf{Out}}\mathcal{M}_j=\emptyset</annotation></semantics></math>.
Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>
be their corresponding functions. For convenience, we put
<!-- (no par break) --> <span class="math display">$$\begin{align*}
    A &amp;=\operatorname{\mathbf{In}}\mathcal{M}_i \\
    B &amp;=\operatorname{\mathbf{Out}}\mathcal{M}_i \\
    C &amp;=\operatorname{\mathbf{In}}\mathcal{M}_j \\
    \intertext{and}
    D &amp;=\operatorname{\mathbf{Out}}\mathcal{M}_j,
\end{align*}$$</span> <!-- (no par break) --> so that
<!-- (no par break) --> <span class="math display">$$\begin{align*}
    f&amp;: \mathbf{R}^A \to \mathbf{R}^B \\
    \intertext{and}
    g&amp;: \mathbf{R}^C \to \mathbf{R}^D,
\end{align*}$$</span> <!-- (no par break) --> with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∩</mo><mi>B</mi><mo>=</mo><mi>C</mi><mo>∩</mo><mi>D</mi><mo>=</mo><mi>A</mi><mo>∩</mo><mi>D</mi><mo>=</mo><mi>B</mi><mo>∩</mo><mi>D</mi><mo>=</mo><mi>∅</mi></mrow><annotation encoding="application/x-tex">A\cap B=C\cap D=A\cap D=B\cap D=\emptyset</annotation></semantics></math>.</p>
<p>At this point, it is possible to see how we might combine these two
direct modules to come up with something that is itself a module; the
key is to think in terms of module inputs and outputs: Given mappings
for all values in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and all values in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
that aren’t in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>,
we can obtain mappings for all values in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
as follows: Since we know all the inputs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
to module
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_i</annotation></semantics></math>,
we can use the module to obtain all the outputs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>.
Now we know all the inputs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
to module
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_j</annotation></semantics></math>—both
those that <em>aren’t</em> in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
(which were given at the outset), and those that <em>are</em> in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
(which were obtained by applying module
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_i</annotation></semantics></math>).
This yields all the outputs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
of module
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_j</annotation></semantics></math>.
We can also describe this more formally, as we now proceed to do.</p>
<p>We define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ℳ</mi><mi>i</mi></msub><mo>+</mo><msub><mi>ℳ</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{M}_i + \mathcal{M}_j</annotation></semantics></math>,
the <em>ordered sum of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_j</annotation></semantics></math></em>,
to be the direct module whose corresponding function
<!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>*</mo><mi>g</mi><mo>:</mo><msup><mi>𝐑</mi><mrow><mi>A</mi><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mo>∖</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup><mo>→</mo><msup><mi>𝐑</mi><mrow><mi>B</mi><mo>∪</mo><mi>D</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\begin{equation}
    f\ast g: \mathbf{R}^{ A\cup (C\smallsetminus B)}\to\mathbf{R}^{ B\cup D} \label{eq:ordered_sum_function}
\end{equation}</annotation></semantics></math><!-- (no par break) -->
is defined by <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>*</mo><mi>g</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo>∘</mo><msup><mi>π</mi><mrow><mi>A</mi><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mo>∖</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mi>A</mi></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>g</mi><mo>∘</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>π</mi><mrow><mi>A</mi><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mo>∖</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mi>C</mi><mo>∖</mo><mi>B</mi></mrow></msup><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>π</mi><mrow><mi>B</mi><mo>→</mo><mi>C</mi><mo>∩</mo><mi>B</mi></mrow></msup><mo>∘</mo><mi>f</mi><mo>∘</mo><msup><mi>π</mi><mrow><mi>A</mi><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mo>∖</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mi>A</mi></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
    f\ast g = (f\circ\pi^{ A\cup (C\smallsetminus B)\to A})
              \cup
              (g\circ(
                \pi^{ A\cup (C\smallsetminus B)
                     \to C\smallsetminus B}
                  \cup
                (\pi^{ B\to C\cap B}\circ
                f\circ
                \pi^{ A\cup (C\smallsetminus B)\to A}))). \label{eq:ordered_sum}
\end{equation}</annotation></semantics></math><!-- (no par break) -->
(Note that if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>∩</mo><mi>C</mi><mo>=</mo><mi>∅</mi></mrow><annotation encoding="application/x-tex">B\cap C=\emptyset</annotation></semantics></math>,
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>∖</mo><mi>B</mi><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">C\smallsetminus B=C</annotation></semantics></math>,
and reduces to <!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>*</mo><mi>g</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo>∘</mo><msup><mi>π</mi><mrow><mi>A</mi><mo>∪</mo><mi>C</mi><mo>→</mo><mi>A</mi></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>g</mi><mo>∘</mo><msup><mi>π</mi><mrow><mi>A</mi><mo>∪</mo><mi>C</mi><mo>→</mo><mi>C</mi></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
    f\ast g = (f\circ\pi^{ A\cup C\to A})
              \cup
              (g\circ\pi^{ A\cup C \to C}).
\end{equation}</annotation></semantics></math><!-- (no par break) -->
In this case, the ordering is immaterial, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ℳ</mi><mi>j</mi></msub><mo>+</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>=</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>+</mo><msub><mi>ℳ</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{M}_j+\mathcal{M}_i=\mathcal{M}_i+\mathcal{M}_j</annotation></semantics></math>,
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>*</mo><mi>f</mi><mo>=</mo><mi>f</mi><mo>*</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">g\ast f=f\ast g</annotation></semantics></math>.)</p>
<p>Recalling that the inputs and outputs of a direct module function
must be disjoint, we can check that this is indeed the case for the sum.
First we note that whenever we can take the ordered sum of two modules
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_j</annotation></semantics></math>,
<!-- (no par break) --> <span class="math display">$$\begin{align}
    \operatorname{\mathbf{In}}(\mathcal{M}_i+\mathcal{M}_j) &amp;=
\operatorname{\mathbf{In}}\mathcal{M}_i \cup
(\operatorname{\mathbf{In}}M_j\smallsetminus
\operatorname{\mathbf{Out}}\mathcal{M}_i) \label{eq:input_of_sum} \\
    \intertext{and}
    \operatorname{\mathbf{Out}}(\mathcal{M}_i+\mathcal{M}_j) &amp;=
\operatorname{\mathbf{Out}}\mathcal{M}_i\cup\operatorname{\mathbf{Out}}\mathcal{M}_j.
\label{eq:output_of_sum}
\end{align}$$</span> <!-- (no par break) --> (The fact that the set of
inputs for the ordered sum is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐈𝐧</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mo>𝐈𝐧</mo><msub><mi>M</mi><mi>j</mi></msub><mo>∖</mo><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{In}}\mathcal{M}_i \cup
(\operatorname{\mathbf{In}}M_j\smallsetminus \operatorname{\mathbf{Out}}\mathcal{M}_i)</annotation></semantics></math>
is readily apparent from : the domain of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>*</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f\ast g</annotation></semantics></math>
being
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mrow><mi>A</mi><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mo>∖</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup><annotation encoding="application/x-tex">\mathbf{R}^{
A\cup (C\smallsetminus B)}</annotation></semantics></math> corresponds
to the inputs for the corresponding module being
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mo>∖</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A\cup (C\smallsetminus B)</annotation></semantics></math>,
which is just
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐈𝐧</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mo>𝐈𝐧</mo><msub><mi>M</mi><mi>j</mi></msub><mo>∖</mo><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{In}}\mathcal{M}_i \cup (\operatorname{\mathbf{In}}M_j\smallsetminus \operatorname{\mathbf{Out}}\mathcal{M}_i)</annotation></semantics></math>.
Similarly for the outputs.)</p>
<p>Using this, we then have that <!-- (no par break) --> <span class="math display">$$\begin{alignat*}{2}
    \operatorname{\mathbf{In}}(\mathcal{M}_i+\mathcal{M}_j) \cap
\operatorname{\mathbf{Out}}(\mathcal{M}_i+\mathcal{M}_j)
&amp;=\;&amp;&amp;
        (\operatorname{\mathbf{In}}\mathcal{M}_i \cup
(\operatorname{\mathbf{In}}M_j \smallsetminus
\operatorname{\mathbf{Out}}\mathcal{M}_i)) \cap
        (\operatorname{\mathbf{Out}}\mathcal{M}_i \cup
\operatorname{\mathbf{Out}}\mathcal{M}_j)
            \quad \text{by \ref{eq:input_of_sum} and
\ref{eq:output_of_sum}} \\
        &amp;= &amp;&amp;(\operatorname{\mathbf{In}}\mathcal{M}_i \cap
\operatorname{\mathbf{Out}}\mathcal{M}_i) \\
           &amp;&amp;&amp;        \cup
              (\operatorname{\mathbf{In}}\mathcal{M}_i \cap
\operatorname{\mathbf{Out}}\mathcal{M}_j) \\
           &amp;&amp;&amp;        \cup
              ((\operatorname{\mathbf{In}}M_j \smallsetminus
\operatorname{\mathbf{Out}}\mathcal{M}_i) \cap
\operatorname{\mathbf{Out}}\mathcal{M}_i) \\
           &amp;&amp;&amp;        \cup
              ((\operatorname{\mathbf{In}}M_j \smallsetminus
\operatorname{\mathbf{Out}}\mathcal{M}_i) \cap
\operatorname{\mathbf{Out}}\mathcal{M}_j)
                 \qquad \text{by distributivity of $\cap$ over $\cup$}
\\
        &amp;= &amp;&amp;\emptyset \cup \emptyset \cup \emptyset \cup
\emptyset \\
        &amp;= &amp;&amp;\emptyset
\end{alignat*}$$</span> <!-- (no par break) --> That each of the
intersections in the distributive expansion is empty is easily verified:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐈𝐧</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>∩</mo><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{In}}\mathcal{M}_i \cap \operatorname{\mathbf{Out}}\mathcal{M}_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mo>𝐈𝐧</mo><msub><mi>M</mi><mi>j</mi></msub><mo>∖</mo><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>∩</mo><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\operatorname{\mathbf{In}}M_j
\smallsetminus \operatorname{\mathbf{Out}}\mathcal{M}_i) \cap \operatorname{\mathbf{Out}}\mathcal{M}_j)</annotation></semantics></math>
are both empty as a consequence of direct modules having non-overlapping
inputs and outputs.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mo>𝐈𝐧</mo><msub><mi>M</mi><mi>j</mi></msub><mo>∖</mo><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>∩</mo><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">(\operatorname{\mathbf{In}}M_j \smallsetminus \operatorname{\mathbf{Out}}\mathcal{M}_i) \cap \operatorname{\mathbf{Out}}\mathcal{M}_i</annotation></semantics></math>
must be empty since a member of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐈𝐧</mo><msub><mi>M</mi><mi>J</mi></msub></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{In}}M_J</annotation></semantics></math>
that is <em>not</em> in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{Out}}\mathcal{M}_i</annotation></semantics></math>
can’t also be <em>in</em>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{Out}}\mathcal{M}_i</annotation></semantics></math>.
Finally,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐈𝐧</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>∩</mo><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>j</mi></msub><mo>=</mo><mi>∅</mi></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{In}}\mathcal{M}_i\cap\operatorname{\mathbf{Out}}\mathcal{M}_j=\emptyset</annotation></semantics></math>
was a stipulation made when defining the ordered sum of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℳ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\mathcal{M}_j</annotation></semantics></math>.</p>
<p>Equation perhaps requires a little explication in order to be
comprehended.</p>
<p>Suppose we are given some value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>
in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mrow><mi>A</mi><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mo>∖</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup><annotation encoding="application/x-tex">\mathbf{R}^{ A\cup
(C\smallsetminus B)}</annotation></semantics></math>, the domain of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>*</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f\ast g</annotation></semantics></math>.
We can describe
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo>*</mo><mi>g</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><msup><mi>𝐑</mi><mrow><mi>B</mi><mo>∪</mo><mi>D</mi></mrow></msup></mrow><annotation encoding="application/x-tex">(f\ast g)(\mathbf{x})\in\mathbf{R}^{ B\cup D}</annotation></semantics></math>
by describing the way to compute how
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo>*</mo><mi>g</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(f\ast g)(\mathbf{x})</annotation></semantics></math>
maps each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>B</mi><mo>∪</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">y\in B\cup D</annotation></semantics></math>
into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐑</mi><annotation encoding="application/x-tex">\mathbf{R}</annotation></semantics></math>.</p>
<p>First suppose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">y\in B</annotation></semantics></math>.
Then we need only look at the first component in the union on the
right-hand side of —namely,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∘</mo><msup><mi>π</mi><mrow><mi>A</mi><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mo>∖</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mi>A</mi></mrow></msup></mrow><annotation encoding="application/x-tex">f\circ\pi^{ A\cup (C\smallsetminus B)\to A}</annotation></semantics></math>.
The projection
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>π</mi><mrow><mi>A</mi><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mo>∖</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mi>A</mi></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>𝐱</mi><mo stretchy="false" form="prefix">|</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\pi^{
A\cup (C\smallsetminus B)\to A}(\mathbf{x}) = \mathbf{x}|A</annotation></semantics></math>
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>A</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^A</annotation></semantics></math>
tells us that we need consider only the coordinates of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>
that correspond to members of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>.
Once we have a vector in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>A</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^A</annotation></semantics></math>,
we can apply the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
to obtain a value in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>B</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^B</annotation></semantics></math>.
This is all we need, since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
is in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>.</p>
<p>Now suppose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">y\in D</annotation></semantics></math>.
Here we need to look at the somewhat more complicated second component
of the right-hand side of , that is,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>π</mi><mrow><mi>A</mi><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mo>∖</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mi>C</mi><mo>∖</mo><mi>B</mi></mrow></msup><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>π</mi><mrow><mi>B</mi><mo>→</mo><mi>C</mi><mo>∩</mo><mi>B</mi></mrow></msup><mo>∘</mo><mi>f</mi><mo>∘</mo><msup><mi>π</mi><mrow><mi>A</mi><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mo>∖</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mi>A</mi></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">g\circ(\pi^{ A\cup (C\smallsetminus B)
\to C\smallsetminus B} \cup (\pi^{ B\to C\cap B}\circ f\circ \pi^{
A\cup (C\smallsetminus B)\to A}))</annotation></semantics></math>. Since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><msup><mi>𝐑</mi><mi>C</mi></msup><mo>→</mo><msup><mi>𝐑</mi><mi>D</mi></msup></mrow><annotation encoding="application/x-tex">g: \mathbf{R}^C\to\mathbf{R}^D</annotation></semantics></math>,
we need to feed
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>
some value in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>C</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^C</annotation></semantics></math>
to obtain a mapping to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐑</mi><annotation encoding="application/x-tex">\mathbf{R}</annotation></semantics></math>
of values (such as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>)
in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>.
But
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>
is in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mrow><mi>A</mi><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mo>∖</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup><annotation encoding="application/x-tex">\mathbf{R}^{A\cup(C\smallsetminus
B)}</annotation></semantics></math>, so
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>
only tells how values in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
that aren’t also in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
are mapped. The mapping for these values corresponds to the projection
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>π</mi><mrow><mi>A</mi><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mo>∖</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mi>C</mi><mo>∖</mo><mi>B</mi></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>𝐱</mi><mo stretchy="false" form="prefix">|</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mo>∖</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi^{ A\cup (C\smallsetminus B) \to C\smallsetminus
B}(\mathbf{x}) = \mathbf{x}|(C\smallsetminus B)</annotation></semantics></math>,
a value in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mrow><mi>C</mi><mo>∖</mo><mi>B</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{R}^{C\smallsetminus B}</annotation></semantics></math>.
To find the portion of the mapping we need that belongs to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mrow><mi>C</mi><mo>∩</mo><mi>B</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{R}^{C\cap B}</annotation></semantics></math>,
we look at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>π</mi><mrow><mi>B</mi><mo>→</mo><mi>C</mi><mo>∩</mo><mi>B</mi></mrow></msup><mo>∘</mo><mi>f</mi><mo>∘</mo><msup><mi>π</mi><mrow><mi>A</mi><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mo>∖</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mi>A</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\pi^{ B\to C\cap B}\circ
f\circ \pi^{ A\cup (C\smallsetminus B)\to A}</annotation></semantics></math>.
As we have just seen,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∘</mo><msup><mi>π</mi><mrow><mi>A</mi><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mo>∖</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mi>A</mi></mrow></msup></mrow><annotation encoding="application/x-tex">f\circ \pi^{ A\cup (C\smallsetminus B)\to A}</annotation></semantics></math>
maps
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>
to a member of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>B</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^B</annotation></semantics></math>.
Then we can apply the projection
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>π</mi><mrow><mi>B</mi><mo>→</mo><mi>C</mi><mo>∩</mo><mi>B</mi></mrow></msup><annotation encoding="application/x-tex">\pi^{ B\to C\cap
B}</annotation></semantics></math> to obtain a member of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mrow><mi>C</mi><mo>∩</mo><mi>B</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{R}^{C\cap B}</annotation></semantics></math>.
Taking the union of the components in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mrow><mi>C</mi><mo>∖</mo><mi>B</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{R}^{C\smallsetminus B}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mrow><mi>C</mi><mo>∩</mo><mi>B</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{R}^{C\cap B}</annotation></semantics></math>
gives us a value in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>C</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^C</annotation></semantics></math>,
to which we can apply function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>.
The result is a function in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐑</mi><mi>D</mi></msup><annotation encoding="application/x-tex">\mathbf{R}^D</annotation></semantics></math>
telling how all values (such as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>)
in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
are mapped.</p>
</div>
<div class="section level5">
<h5 class="unnumbered" id="general-ordered-sum">General ordered sum<a class="anchor" aria-label="anchor" href="#general-ordered-sum"></a>
</h5>
<p>We now generalize the notion of an ordered sum of two direct modules
to the ordered sum of any finite number of direct modules.</p>
<p>Suppose we have an ordered collection
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ℳ</mi><mn>1</mn></msub><mo>,</mo><msub><mi>ℳ</mi><mn>2</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>ℳ</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathcal{M}_1, \mathcal{M}_2, \dots, \mathcal{M}_n)</annotation></semantics></math>
of direct modules. As is the case with all direct modules,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐈𝐧</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>∩</mo><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>=</mo><mi>∅</mi></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{In}}\mathcal{M}_i\cap\operatorname{\mathbf{Out}}\mathcal{M}_i=\emptyset</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>.
Further, assume that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>∪</mo><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>j</mi></msub><mo>=</mo><mi>∅</mi></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{Out}}\mathcal{M}_i\cup\operatorname{\mathbf{Out}}\mathcal{M}_j=\emptyset</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≠</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i\neq j</annotation></semantics></math>,
and that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐈𝐧</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>∩</mo><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>j</mi></msub><mo>=</mo><mi>∅</mi></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{In}}\mathcal{M}_i\cap\operatorname{\mathbf{Out}}\mathcal{M}_j=\emptyset</annotation></semantics></math>
whenever
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i&lt;j</annotation></semantics></math>.
Then we define the ordered sum
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>ℳ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{i=1}^n\mathcal{M}_i</annotation></semantics></math>
recursively as follows: <!-- (no par break) --> <span class="math display">$$\begin{alignat}{2}
    \sum_{i=1}^k\mathcal{M}_i &amp;= M_1 &amp;&amp; \qquad\text{for
$k=1$} \notag \\
    \sum_{i=1}^k\mathcal{M}_i &amp;= \sum_{i=1}^{k-1}\mathcal{M}_i
                        + \mathcal{M}_k &amp;&amp; \qquad
                        \text{for $1&lt;k\leq
n$}\label{eq:recursive_module_sum}
\end{alignat}$$</span></p>
<p>Things are not quite as simple as this, however, since we must show
that the ordered sum given on the right-hand side of is always defined.
Specifically, we must show that <!-- (no par break) --> <span class="math display">$$\begin{align}
    \operatorname{\mathbf{Out}}\sum_{i=1}^{k-1}\mathcal{M}_i \cap
\operatorname{\mathbf{Out}}\mathcal{M}_k &amp;= \emptyset
        \label{eq:general_sum_disjoint_outputs} \\
\intertext{and}
    \operatorname{\mathbf{In}}\sum_{i=1}^{k-1}\mathcal{M}_i \cap
\operatorname{\mathbf{Out}}\mathcal{M}_k &amp;= \emptyset.
\label{eq:general_sum_general_condition}
\end{align}$$</span></p>
<p>But it easily follows by induction from equation that
<!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐎𝐮𝐭</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>ℳ</mi><mi>i</mi></msub><mo>=</mo><munderover><mo>⋃</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo>𝐎𝐮𝐭</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation*}
    \operatorname{\mathbf{Out}}\sum_{i=1}^{k-1}\mathcal{M}_i = \bigcup_{i=1}^{k-1}\operatorname{\mathbf{Out}}\mathcal{M}_i,
\end{equation*}</annotation></semantics></math><!-- (no par break) -->
and easily follows from this, the distributivity of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∩</mo><annotation encoding="application/x-tex">\cap</annotation></semantics></math>
over
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∪</mo><annotation encoding="application/x-tex">\cup</annotation></semantics></math>,
and the assumption that the outputs of the modules are pairwise
disjoint.</p>
<p>To prove , we first observe that it follows immediately from that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐈𝐧</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>+</mo><msub><mi>ℳ</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>⊆</mo><mo>𝐈𝐧</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mo>∪</mo><mo>𝐈𝐧</mo><msub><mi>M</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\operatorname{\mathbf{In}}(\mathcal{M}_i+\mathcal{M}_j)
\subseteq \operatorname{\mathbf{In}}\mathcal{M}_i \cup \operatorname{\mathbf{In}}M_j</annotation></semantics></math>,
and from this it is easy to show by induction that
<!-- (no par break) -->
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>𝐈𝐧</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>ℳ</mi><mi>i</mi></msub><mo>⊆</mo><munderover><mo>⋃</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo>𝐈𝐧</mo><msub><mi>ℳ</mi><mi>i</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
    \operatorname{\mathbf{In}}\sum_{i=1}^{k-1}\mathcal{M}_i \subseteq \bigcup_{i=1}^{k-1}\operatorname{\mathbf{In}}\mathcal{M}_i.
\end{equation}</annotation></semantics></math><!-- (no par break) -->
Since a stipulation in defining the ordered sum of modules was that
output of each module in the ordered collection is disjoint from the
inputs of each module occuring earlier in the ordering, in light of the
distributivity of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∩</mo><annotation encoding="application/x-tex">\cap</annotation></semantics></math>
over
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∪</mo><annotation encoding="application/x-tex">\cup</annotation></semantics></math>,
the desired result immediately follows.</p>
<!-- Don't number any sections or subsections from here on out. -->
</div>
</div>
</div>
</div>
<div class="section level2">
<h2 id="appendix-degenerate-biocro-systems">Appendix: Degenerate BioCro systems<a class="anchor" aria-label="anchor" href="#appendix-degenerate-biocro-systems"></a>
</h2>
<p>This appendix is meant to demonstrate certain edge cases and
“off-label” uses of BioCro systems. All of these systems are set up
using the R interface. A similar set of systems that use the C++ library
directly could be written in C++.</p>
<div class="section level3">
<h3 id="a-minimal-system">A minimal system<a class="anchor" aria-label="anchor" href="#a-minimal-system"></a>
</h3>
<p>This system contains the absolute minimum number of quantities. Since
it has only a single time point, <code>timestep</code> is present only
to satisfy a formal requirement of the validity checker; it is otherwise
meaningless.</p>
<p>A formal requirement of the R interface (but not of the C++
interface) is that the set of driver variables either contains
<code>time</code> or contains both <code>doy</code> and
<code>hour</code>. In the latter case, <code>time</code> will
automatically be calculated from <code>doy</code> and
<code>hour</code>.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/biocro/biocro" class="external-link">BioCro</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="../../reference/run_biocro.html">run_biocro</a></span><span class="op">(</span>parameters <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>timestep<span class="op">=</span><span class="fl">1</span><span class="op">)</span>, drivers <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>time<span class="op">=</span><span class="fl">45.625</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   ncalls   time</span></span>
<span><span class="co">## 1      1 45.625</span></span></code></pre>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../../reference/run_biocro.html">run_biocro</a></span><span class="op">(</span>parameters <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>timestep<span class="op">=</span><span class="fl">1</span><span class="op">)</span>, drivers <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>doy<span class="op">=</span><span class="fl">80</span>, hour<span class="op">=</span><span class="fl">14.25</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   doy fractional_doy  hour ncalls    time</span></span>
<span><span class="co">## 1  80       80.59375 14.25      1 1910.25</span></span></code></pre>
<p>Note that <code>ncalls</code> always shows up in the output data
frame, even though it is constant and even though it is not a system
variable.</p>
<p>Note also that if <code>time</code> is a driver, it dominates:
<code>doy</code> and <code>hour</code> (if present) are overwritten. If
<code>time</code> is not present, both <code>doy</code> and
<code>hour</code> must be; if only one is, <code>time</code> cannot be
calculated and we get an error:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../../reference/run_biocro.html">run_biocro</a></span><span class="op">(</span></span>
<span>    parameters <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>timestep<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>    differential_module_names <span class="op">=</span> <span class="st">'BioCro:harmonic_oscillator'</span>,</span>
<span>    drivers <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>doy<span class="op">=</span><span class="fl">80</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Error: No `time` variable found in the `drivers` dataframe.</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="a-system-having-a-differential-variable-but-no-differential-module">A system having a differential variable but no differential
module<a class="anchor" aria-label="anchor" href="#a-system-having-a-differential-variable-but-no-differential-module"></a>
</h3>
<p>As noted in Section , it is the <code>initial_values</code> parameter
that determines which variables are differential variables. Usually,
each differential variable will be an output of one or more differential
modules, but this is not required. Differential variables that are
<em>not</em> in the output of any differential module are assumed to
have a derivative of zero; that is, they are constant. This system
exhibits such a case.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../../reference/run_biocro.html">run_biocro</a></span><span class="op">(</span>initial_values <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">52</span><span class="op">)</span>,</span>
<span>           parameters <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>timestep<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>           drivers <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>time<span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   ncalls time  x</span></span>
<span><span class="co">## 1      5    0 52</span></span>
<span><span class="co">## 2      5    1 52</span></span>
<span><span class="co">## 3      5    2 52</span></span>
<span><span class="co">## 4      5    3 52</span></span>
<span><span class="co">## 5      5    4 52</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="an-off-label-use-of-run_biocro">An <em>off-label</em> use of <code>run_biocro</code><a class="anchor" aria-label="anchor" href="#an-off-label-use-of-run_biocro"></a>
</h3>
<p>Here is an example of what might be called an “off-label” use of a
BioCro system. This system really doesn’t deserve to be called a
dynamical system at all. Although the <em>drivers</em> parameter
contains five rows of temporal and spacial data (each row specifies a
time and a place), the rows have no inherent relationship to one
another: they do not represent any sort of evolution of a system over
time. The times specified by the rows aren’t even in chronological
order: although the <code>timestep</code> variable is <em>supposed</em>
to indicate the temporal relationship between successive rows of the
<code>drivers</code> parameter value, this is a convention only, and it
is not enforced.</p>
<p>Nevertheless, this system is useful: it uses the
<code>BioCro:solar_position_michalsky</code> module to compute the
cosine of the zenith angle of the sun at noon in various terrestrial
locations on various days of the year. We could have gotten the same
information using five calls to <code>run_biocro</code> with drivers
having a single row, but doing it in one call is more convenient.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../../reference/run_biocro.html">run_biocro</a></span><span class="op">(</span>parameters <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>timestep<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>                     drivers <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>doy <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">355</span>, <span class="fl">172</span>, <span class="fl">80</span>, <span class="fl">80</span>, <span class="fl">80</span><span class="op">)</span>,</span>
<span>                                          hour <span class="op">=</span> <span class="fl">12</span>,</span>
<span>                                          time_zone_offset <span class="op">=</span> <span class="op">-</span><span class="fl">6</span>,</span>
<span>                                          year <span class="op">=</span> <span class="fl">2022</span>,</span>
<span>                                          lat <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">40</span>, <span class="fl">40</span>, <span class="fl">40</span>, <span class="fl">0</span>, <span class="fl">89</span><span class="op">)</span>,</span>
<span>                                          longitude <span class="op">=</span> <span class="op">-</span><span class="fl">88</span><span class="op">)</span>,</span>
<span>                     direct_module_names <span class="op">=</span> <span class="st">'BioCro:solar_position_michalsky'</span><span class="op">)</span></span>
<span><span class="va">result</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'lat'</span>, <span class="st">'longitude'</span>, <span class="st">'doy'</span>, <span class="st">'hour'</span>, <span class="st">'cosine_zenith_angle'</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">##   lat longitude doy hour cosine_zenith_angle</span></span>
<span><span class="co">## 1  40       -88 355   12          0.44655908</span></span>
<span><span class="co">## 2  40       -88 172   12          0.95824629</span></span>
<span><span class="co">## 3  40       -88  80   12          0.77093280</span></span>
<span><span class="co">## 4   0       -88  80   12          0.99996308</span></span>
<span><span class="co">## 5  89       -88  80   12          0.02509952</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="a-system-having-only-drivers-and-the-obligatory-timestep-parameter">A system having only drivers (and the obligatory
<code>timestep</code> parameter)<a class="anchor" aria-label="anchor" href="#a-system-having-only-drivers-and-the-obligatory-timestep-parameter"></a>
</h3>
<p>Like the minimal system shown in the first example, this system has
no differential variables and no modules. But the drivers include some
driver variables that aren’t time related. Like all systems not having
any modules, it doesn’t really <em>do</em> anything.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../../reference/run_biocro.html">run_biocro</a></span><span class="op">(</span>parameters <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>timestep<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>                     drivers <span class="op">=</span> <span class="va">weather</span><span class="op">$</span><span class="va">`2005`</span><span class="op">[</span><span class="fl">1000</span><span class="op">:</span><span class="fl">1010</span>,<span class="op">]</span><span class="op">)</span></span>
<span><span class="va">result</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'year'</span>, <span class="st">'doy'</span>, <span class="st">'hour'</span>, <span class="st">'precip'</span>, <span class="st">'rh'</span>, <span class="st">'solar'</span>, <span class="st">'temp'</span>, <span class="st">'windspeed'</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">##    year doy hour precip   rh solar  temp windspeed</span></span>
<span><span class="co">## 1  2005  42   15 0.0106 0.74   756 4.530      7.48</span></span>
<span><span class="co">## 2  2005  42   16 0.0106 0.70   421 5.080      7.45</span></span>
<span><span class="co">## 3  2005  42   17 0.0106 0.73   102 4.370      5.94</span></span>
<span><span class="co">## 4  2005  42   18 0.0106 0.80     1 2.460      4.78</span></span>
<span><span class="co">## 5  2005  42   19 0.0106 0.83     0 1.650      4.12</span></span>
<span><span class="co">## 6  2005  42   20 0.0106 0.84     0 1.210      3.57</span></span>
<span><span class="co">## 7  2005  42   21 0.0106 0.87     0 0.635      3.26</span></span>
<span><span class="co">## 8  2005  42   22 0.0106 0.86     0 0.550      3.76</span></span>
<span><span class="co">## 9  2005  42   23 0.0106 0.85     0 0.890      4.82</span></span>
<span><span class="co">## 10 2005  43    0 0.0000 0.82     0 1.250      4.96</span></span>
<span><span class="co">## 11 2005  43    1 0.0000 0.83     0 1.030      5.67</span></span></code></pre>
<p>The weather information this run displays could just as easily be
displayed using</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">weather</span><span class="op">$</span><span class="va">`2005`</span><span class="op">[</span><span class="fl">1000</span><span class="op">:</span><span class="fl">1010</span>,</span>
<span>               <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'year'</span>, <span class="st">'doy'</span>, <span class="st">'hour'</span>, <span class="st">'precip'</span>, <span class="st">'rh'</span>, <span class="st">'solar'</span>, <span class="st">'temp'</span>, <span class="st">'windspeed'</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<!-- footnotes -->
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-alma99954905266605899" class="csl-entry">
Barreira, Luís. 2019. <em>Dynamical Systems by Example</em>. 1st ed.
2019. Problem Books in Mathematics. Cham: Springer International
Publishing.
</div>
<div id="ref-alma99954908866305899" class="csl-entry">
Dale, Andrew I. 1995. <em>Philosophical Essay on Probabilities /
<span>P</span>ierre-<span>S</span>imon <span>L</span>aplace</em>. 1st
ed. 1995. Sources in the History of Mathematics and Physical Sciences;
13. New York: Springer.
</div>
<div id="ref-alma99496872912205899" class="csl-entry">
Deutsch, Andreas. 2005. <em>Cellular Automaton Modeling of Biological
Pattern Formation: Characterization, Applications, and Analysis</em>.
Modeling and Simulation in Science, Engineering and Technology. Boston:
Birkhäuser.
</div>
<div id="ref-Giunti1997-GIUCDS" class="csl-entry">
Giunti, Marco. 1997. <em>Computation, Dynamics, and Cognition</em>.
Oxford University Press.
</div>
<div id="ref-Giunti&amp;Mazzola" class="csl-entry">
Giunti, Marco, and Claudio Mazzola. 2012. <span>“Dynamical Systems on
Monoids: Toward a General Theory of Deterministic Systems and
Motion.”</span> In <em>Methods, Models, Simulations &amp; Approaches
Towards A General Theory of Change - Proceedings of the Fifth National
Conference of the Italian Systems Society</em>, 173–85. <a href="https://www.researchgate.net/publication/272943599_Dynamical_Systems_on_Monoids_Toward_a_General_Theory_of_Deterministic_Systems_and_Motion" class="external-link">https://www.researchgate.net/publication/272943599_Dynamical_Systems_on_Monoids_Toward_a_General_Theory_of_Deterministic_Systems_and_Motion</a>.
</div>
<div id="ref-alma99454477012205899" class="csl-entry">
Khalil, Hassan K. 2002. <em>Nonlinear Systems</em>. 3rd ed. Upper Saddle
River, N.J: Prentice Hall.
</div>
<div id="ref-10.1093/insilicoplants/diac003" class="csl-entry">
Lochocki, Edward B., Scott Rohde, Deepak Jaiswal, Megan L. Matthews,
Fernando Miguez, Stephen P. Long, and Justin M. McGrath. 2022.
<span>“BioCro II: A Software Package for Modular Crop Growth
Simulations.”</span> <em>In Silico Plants</em> 4 (1). <a href="https://doi.org/10.1093/insilicoplants/diac003" class="external-link">https://doi.org/10.1093/insilicoplants/diac003</a>.
</div>
<div id="ref-alma99267312205899" class="csl-entry">
Mesarović, Mihajlo D., and Yasuhiko Takahara. 1975. <em>General Systems
Theory: Mathematical Foundations</em>. Mathematics in Science and
Engineering, v. 113. New York: Academic Press.
</div>
<div id="ref-vaught" class="csl-entry">
Vaught, Robert L. 1985. <em>Set Theory: An Introduction</em>. Boston:
Birkhäuser.
</div>
</div>
</div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Justin M. McGrath, Edward B. Lochocki, Yufeng He, Scott W. Oswald, Scott Rohde, Deepak Jaiswal, Megan L. Matthews, Fernando E. Miguez, Stephen P. Long.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
